<!-- Created by TopStyle Trial - www.topstyle4.com -->
<!DOCTYPE>
<html>
<head>
  <title>КИС</title>
  <link rel="stylesheet" type="text/css" href="styles/styles.css" />
  <script src="scripts/jquery-3.2.1.min.js"></script>
  <script src="scripts/bootstrap-collapse.js"></script>
  <script src="scripts/main.js"></script>
</head>

<body>
<div class="header-main">
  Лабораторные работы по дисциплине <br>"Корпоративные информационные системы"
</div>
<div class="main-container">

  <div class="menu">
    <ul>
      <li class="menu_lab-block hvr-float-shadow active" id="lab-1">
        <img src="images/folder.png" class="img-default" alt="1 лабораторная">
        <img src="images/folderBlue.png" class="img-hover" alt="1 лабораторная">
        <div class="menu_lab-block__number">#1</div>
      </li>
      <li class="menu_lab-block hvr-float-shadow" id="lab-2">
        <img src="images/folder.png" alt="2 лабораторная">
        <img src="images/folderBlue.png" class="img-hover" alt="2 лабораторная">
        <div class="menu_lab-block__number">#2</div>
      </li>
      <li class="menu_lab-block hvr-float-shadow" id="lab-3">
        <img src="images/folder.png" alt="3 лабораторная">
        <img src="images/folderBlue.png" class="img-hover" alt="3 лабораторная">
        <div class="menu_lab-block__number">#3</div>
      </li>
      <li class="menu_lab-block hvr-float-shadow" id="lab-4">
        <img src="images/folder.png" alt="4 лабораторная">
        <img src="images/folderBlue.png" class="img-hover" alt="4 лабораторная">
        <div class="menu_lab-block__number">#4</div>
      </li>
      <li class="menu_lab-block hvr-float-shadow" id="lab-5">
        <img src="images/folder.png" alt="5 лабораторная">
        <img src="images/folderBlue.png" class="img-hover" alt="5 лабораторная">
        <div class="menu_lab-block__number">#5</div>
      </li>
    </ul>
  </div>

  <div class="content">

    <div id="lab-1-content" class="content-lab active">
      <!--Шапка лабы-->
      <H2 class="lab-title"><B>Лабораторная работа №1</B></H2>
      <H3 class="lab-title"><B>Выборка данных из базы данных с использованием языка
        SQL</B></H3>
      <P class="lab-subtitle"><B>Цель работы:</B> изучить принципы работы с
        базой данных в архитектуре клиент-сервер, изучить спецификации запроса языка баз
        данных SQL, получить практические навыки составления и содержательной
        интерпретации запросов выборки данных (операторов SELECT), а также их выполнения
        на SQL-сервере с использованием клиентских утилит.</P>
      <H3><B>Порядок выполнения работы</B></H3>
      <ol class="numbered-list lab-subtitle">
        <li>Изучить структуру и элементы SQL-запроса выборки, в том
          числе разделы FROM, WHERE, GROUP BY, HAVING, ORDER BY, а также предикаты условия
          поиска и агрегатные функции.</li>
        <li>Изучить операции реляционной алгебры (соединение,
          пересечение, объединение, разность и др.).</li>
        <li>Изучить утилиту ISQL/w, входящую в набор клиентских утилит
          для СУБД SQL Server.</li>
        <li>Изучить состав базы данных книготорговой компании (база
          данных pubs), структуру и семантику ее таблиц.</li>
        <li>Получить у преподавателя номер варианта задания.</li>
        <li>В соответствии с вариантом задания типа А произвести
          содержательную интерпретацию заданных SQL-запросов, выполнить их на SQL-сервере
          с использованием клиентских утилит ISQL/w или SQL Enterprise Manager (SQL-EM),
          проинтерпретировать результаты выполнения запросов.</li>
        <li>В соответствии с вариантом задания В составить SQL-запросы
          по их заданному содержательному описанию, выполнить SQL-запросы на SQL-сервере с
          использованием клиентских утилит ISQL/w или SQL-EM, проинтерпретировать
          результаты выполнения запросов.</li>
        <li>Оформить отчет.</li>
      </ol>
      <H3 align=left><B>Содержание отчета</B></H3>
      <ol class="numbered-list lab-subtitle">
        <li>Титульный лист;</li>
        <li>Цель работы;</li>
        <li>Тексты SQL-запросов и их
        <li>Содержательная интерпретация</li>
        <li>Результаты выполнения запросов по заданиям типа А и В и их интерпретация</li>
        <li>Выводы</li>
      </ol>
      <!-- ------------------------- -->
      <H3 class="lab-subtitle"><B>Основные сведения</B></H3>
      <!--Язык SQL-->
      <div class="accordion-group">
          <h3
              class="accordion-header"
              data-toggle="collapse"
              data-target="#sql"
          >
            Язык SQL
          </h3>
        <div id="sql" class="accordion-body collapse">
          <div class="accordion-inner" >
            <P >Первый международный стандарт языка SQL был принят в 1989 г.
              (SQL/89). В конце 1992 г. Был принят новый международный стандарт SQL/92.
              “Родным” языком Microsoft SQL Server является язык Transact-SQL (T-SQL),
              являющийся диалектом стандартного языка SQL. T-SQL поддерживает большинство
              возможностей языков SQL/89 и SQL/92, а также ряд расширений, увеличивающих
              возможность программирования и гибкость языка. В частности, в язык T-SQL
              добавлены конструкции для задания последовательности операций управления в
              программе (например, if и while), локальных переменных и других конструкций,
              позволяющих писать более сложные запросы и строить программные объекты,
              хранящиеся на сервере, в том числе процедуры и триггеры.</P>
            <P align=justify>Язык SQL включает следующие языки:</P>
            <UL>
              <UL>
                <LI>язык определения данных (Data Definition Language или DDL),
                  предназначенный для добавления, модификации и удаления данных в таблицах;
                <LI>язык модификации данных (Data Modification Language или DML),
                  предназначенный для добавления, модификации и удаления данных в таблицах.
                </LI>
              </UL>
            </UL>
            <P align=justify>В синтаксических конструкциях при описании языка будут
              использоваться следующие соглашения. Нетерминальные элементы заключаются в
              угловые скобки &lt;&gt;. Необязательная конструкция заключается в квадратные
              скобки []. Запись вида {A}… означает повторение конструкции А произвольное число
              раз (включая нулевое). Вертикальные разделители | читаются как “ИЛИ” и служат
              для выбора одной из конструкций, заключенных в скобки.</P>
          </div>
        </div>
      </div>
      <!--Оператор SELECT-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#select"
        >
          Оператор SELECT
        </h3>
        <div id="select" class="accordion-body collapse">
          <div class="accordion-inner" >
            <P align=justify>Оператор SELECT используется для запросов к базе данных и
              выборки результатов. Синтаксис оператора SELECT следующий:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;оператор SELECT&gt;::=
        SELECT [ALL | DISTINCT] &lt;список выборки&gt;
        ORDER BY &lt;спецификация сортировки&gt;]
    &lt;табличное выражение&gt;::=

    FROM &lt;имя таблицы&gt;[{,&lt;имя таблицы&gt;}…]
        [WHERE &lt;условие поиска&gt;]
        [GROUP BY &lt;имя столбца&gt; [{,&lt;имя столбца&gt;}…]
        [HAVING &lt;условие поиска&gt;]
  </code>
            </pre>
            <P align=justify>Если задано ключевое слово DISTINCT, то из результирующей
              таблицы удаляются повторяющиеся строки. Список выборки определяет, какие столбцы
              должны быть возвращены в результирующую таблицу. Данный список представляет
              список арифметических выражений над значениями столбцов таблиц из раздела FROM и
              констант. В простейшем случае он может быть, например, списком имен некоторых
              столбцов таблиц из раздела FROM. В случае, если вместо списка выборки стоит
              звездочка (*), то выбираются все столбцы таблиц из раздела FROM.</P>
            <P align=justify>В разделе FROM определяются таблицы, из которых будут
              извлекаться данные. Следует отметить, что рядом с именем таблицы можно указывать
              еще одно имя - синоним имени таблицы, который можно использовать в других
              разделах табличного выражения.</P>
            <P align=justify>Раздел WHERE служит своего рода фильтром при отборе данных.</P>
            <P align=justify>Выполнение раздела GROUP BY оператора выборки сводится к
              разбиению результирующей таблицы на множество групп строк, которое состоит из
              минимального числа таких групп, в которых для каждого столбца из списка столбцов
              раздела GROUP BY во всех строках каждой группы, включающей более одной строки,
              значения этого столбца совпадают.</P>
            <P align=justify>Результатом выполнения раздела HAVING является сгруппированная
              таблица, содержащая только те группы строк, для которых результат вычисления
              условия поиска является истинным. Условие поиска раздела HAVING задает условие
              на целую группу, а не на индивидуальные строки, поэтому в данном случае прямо
              можно использовать только столбцы, указанные в качестве столбцов группирования в
              разделе GROUP BY.</P>
            <P align=justify>Раздел ORDER BY позволяет установить желаемый порядок просмотра
              результирующей таблицы. Спецификация сортировки имеет следующий синтаксис:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;спецификация сортировки&gt;::= {&lt;целое без знака&gt; | &lt;имя столбца&gt;} [ASC | DESC]
  </code>
      </pre>

            <P align=justify>Как видно, фактически задается список столбцов, и для каждого
              столбца указывается порядок просмотра строк результирующей таблицы в зависимости
              от значений этого столбца (ASC - по возрастанию (умолчание), DESC - по
              убыванию). Указывать сортируемый столбец можно по имени или по порядковому
              номеру в результирующей таблице. </P>
          </div>
        </div>
      </div>
      <!--Предикаты условия поиска-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#search-condition"
        >
          Предикаты условия поиска
        </h3>
        <div id="search-condition" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>В условии поиска могут использоваться следующие предикаты:
              предикат сравнения, предикат BETWEEN , предикат IN, предикат LIKE, предикат
              NULL, предикат с квантором и предикат EXISTS.</P>
            <P align=justify>Предикат IN определяется следующим образом:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;предикат IN&gt;::= &lt;выражение&gt; [NOT] IN (&lt;значение&gt; [,&lt;значение&gt;...] | .&lt;подзапрос&gt;)
  </code>
            </pre>
            <P align=justify>Значение предиката является истинным, когда значение левого
              операнда совпадает хотя бы с одним значением списка правого операнда.
              Использование ключевого слова NOT осуществляет отрицание результата. </P>
            <P align=justify>Подзапрос- это запрос, используемый в предикате условия поиска.
              Результатом выполнения подзапроса является единственный столбец.</P>
            <P align=justify>Предикат BETWEEN определяется следующим образом:</P>
            <P align=justify><I></I></P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;предикат BETWEEN&gt;::= &lt;выражение&gt; [NOT] BETWEEN &lt;выражение&gt; AND &lt;выражение&gt;
  </code>
            </pre>
            <P align=justify>По определению результат x BETWEEN y AND z тот же самый, что
              результат логического выражения x&gt;=y AND x&lt;=z.</P>
            <P align=justify>Предикат LIKE имеет следующий синтаксис:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;предикат LIKE&gt;::= &lt;имя столбца&gt; [NOT] LIKE &lt;шаблон&gt;[ESCAPE &lt;escape-символ&gt;]
  </code>
            </pre>
            <P align=justify>Значение предиката LIKE является истинным, если шаблон является
              подстрокой заданного столбца. При этом, если раздел ESCAPE отсутствует, то при
              составлении шаблона со строкой производится специальная интерпретация
              символов-заместителей шаблона: символ подчеркивания ("_") обозначает любой
              одиночный символ, символ процента ("%") обозначает последовательность
              произвольных символов произвольной длины (может быть нулевой), парные квадратные
              скобки представляют любой символ, записанный в скобках. Если же раздел ESCAPE
              присутствует и специфицирует некоторый одиночный символ x, то пары символов "x_"
              и "x%" представляют одиночные символы "_" и "%" соответственно.</P>
            <P align=justify>Предикат NULL описывается синтаксическим правилом:</P>
            <P align=justify><I>&lt;предикат NULL&gt;::= &lt;имя столбца&gt; IS [NOT]
              NULL</I></P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;предикат NULL&gt;::= &lt;имя столбца&gt; IS [NOT] NULL
  </code>
            </pre>
            <P align=justify>Значение "x IS NULL" является истинным, когда значение x
              неопределено.</P>
            <P align=justify>Предикат EXISTS имеет следующий синтаксис:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;предикат EXISTS&gt;::= EXISTS &lt;подзапрос&gt;
  </code>
            </pre>
            <P align=justify>Значение предиката является истинным, когда результат
              вычисления подзапроса не пуст.</P>
          </div>
        </div>
      </div>
      <!--Агрегатные функции-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#aggregate-functions"
        >
          Агрегатные функции
        </h3>
        <div id="aggregate-functions" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=left>Агрегатные функции (функции множества) в запросе предназначены для
              вычисления некоторого значения для заданного множества строк. Таким множеством
              строк может быть группа строк, если агрегатная функция применяется к
              сгруппированной таблице, или вся таблица. В языке SQL определены следующие
              агрегатные функции:</P>
            <UL>
              <LI>AVG - функция определения среднего значения;</LI>
              <LI>MAX - функция определения максимального значения;</LI>
              <LI>MIN - функция определения минимального значения;</LI>
              <LI>SUM - функция суммирования значений;</LI>
              <LI>COUNT - функция для подсчета числа строк или значений.</LI>
            </UL>
            <P align=justify>Грамматика агрегатных функций следующая:</P>
              <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;агрегатная функция&gt;::= COUNT(*) | &lt;distinct-функция&gt; | &lt;all-функция&gt;

    &lt;агрегатная функция&gt;::= COUNT(*) | &lt;distinct-функция&gt; | &lt;all-функция&gt;

    &lt;all-функция&gt;::= {AVG | MAX | MIN | SUM} ([ALL]&lt;выражение&gt;)
  </code>
            </pre>
            <P align=justify>Вычисление функции COUNT(*) производится путем подсчета числа
              строк в заданном множестве. Функция типа distinct выполняет вычисления только
              над одним столбцом, а в вычислениях используются только уникальные значения
              столбца. При использовании функции типа all список значений формируется из
              значений арифметического выражения, вычисляемого для каждой строки заданного
              множества.</P>
          </div>
        </div>
      </div>
      <!--Операции реляционной алгебры-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#algebra-operations"
        >
          Операции реляционной алгебры
        </h3>
        <div id="algebra-operations" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Большинство SQL-запросов требует одновременного обращения к
              нескольким таблицам. Часто такого рода запросы основываются на операциях
              реляционной алгебры, в частности, соединения, декартова произведения,
              объединения, пересечения и разности. </P>
            <P align=justify>При соединении двух таблиц по некоторому условию образуется
              результирующая таблица, строки которой являются конкатенацией (сцеплением) строк
              первой и второй таблиц и удовлетворяют этому условию. Операцию соединения можно
              реализовать с использованием обычного SQL-запроса типа SELECT-FROM-WHERE. По
              стандарту ANSI операция соединения таблиц может указываться явно в разделе FROM.
              Синтаксис раздела FROM в этом случае следующий:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;раздел FROM&gt;::= FROM &lt;имя таблицы&gt; [JOIN &lt;имя таблицы&gt; ON &lt;условие соединения&gt; ...]
  </code>
            </pre>
            <P align=justify>При выполнении декартова произведения двух таблиц производится
              таблица, строки которой являются конкатенацией строк первой и второй таблиц.
              Операцию декартова произведения можно реализовать с использованием SQL-запроса
              типа SELECT-FROM. По стандарту ANSI операция декартова произведения может
              указываться явно в разделе FROM с использованием ключевой фразы CROSS JOIN.</P>
            <P align=justify>При выполнении операции объединения двух таблиц производится
              таблица, включающая все строки, входящие хотя бы в одну из таблиц-операндов. При
              этом число столбцов и типы данных этих столбцов должны быть одинаковыми для всех
              операндов. Для объединения результирующих таблиц операторов SELECT используется
              ключевое слово UNION.</P>
            <P align=justify>Операция пересечения двух таблиц производит таблицу, включающую
              все строки, входящие в обе исходные таблицы.</P>
            <P align=justify>Таблица, являющаяся разностью двух таблиц, включает все строки,
              входящие в таблицу - первый операнд, такие, что ни одна из них не входит в
              таблицу, являющуюся вторым операндом.</P>
          </div>
        </div>
      </div>
      <!--Работа с утилитой ISQL/w-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#job-isql"
        >
          Работа с утилитой ISQL/w
        </h3>
        <div id="job-isql" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Клиентская утилита ISQL/w используется для тестирования
              SQL-запросов. После запуска данной утилиты необходимо подключиться к серверу.
              При этом в диалоговом окне подсоединения (connect dialog box) необходимо указать
              имя сервера, идентификатор пользователя и пароль. После регистрации окно ISQL/w
              отображает в заголовке информацию о сервере, пользователе и текущей базе данных.
              Окно запросов при этом открыто.</P>
            <P align=justify>Пункты меню File управляют сохранением, чтением и печатью
              запросов, а также подключениями к серверам. Меню Edit позволяет копировать и
              искать строки. Меню Query управляет выполнением запросов и предлагает доступ к
              некоторым общим установкам подключения. Пункты меню Help и Window работают
              практически так же, как и в любом приложении Windows.</P>
            <P align=justify>Кнопки панели инструментов (toolbar) дают те же возможности,
              что и пункты меню, но при однократном нажатии отдельные кнопки особенно удобны.
              Первая кнопка слева (кнопка Новый запрос) позволяет создать новое окно запросов
              и новое подключение к данному серверу с использованием того же идентификатора
              пользователя и пароля. Кроме того, оно позволяет автоматически использовать ту
              же базу данных, что и текущее подсоединение. Одновременные подсоединения удобны,
              поскольку они позволяют работать как два отдельных пользователя, тестируя
              блокировку и многопользовательское поведение, или дают возможность быстро
              посмотреть значение, необходимое для написания сложного запроса в другом
              окне.</P>
            <P align=justify>Другие полезные кнопки находятся справа от окна запросов.
              Крайняя левая кнопка из трех (перечеркнутая крестиком пиктограмма запроса)
              закрывает текущий запрос и подсоединение. Именно таким образом отменяется
              действие кнопки “Новый запрос”.</P>
            <P align=justify>Вторая кнопка с указывающей направо стрелкой становится
              зеленой, когда вводится любой текст в текстовой области окна запросов. Эта
              кнопка выполнения. При нажатии ее по окончании ввода запроса, текст запроса
              будет передан на сервер. Кнопка будет серой, когда в окне нет или когда запрос
              уже выполняется.</P>
            <P align=justify>Третья кнопка - это квадрат, имеющий красный цвет, когда запрос
              выполняется. Это кнопка отмены запроса.</P>
            <P align=justify>Текстовая область может использоваться для ввода запроса,
              просмотра результата выполнения запроса, просмотра статистики ввода-вывода при
              выполнении запроса, а также для просмотра плана запроса (?). Для перехода к
              указанным режимам использования текстовой области необходимо выбрать закладки
              Query, Results, Statistics I/O и Showplan, соответственно.</P>
            <P align=justify>Вызвать утилиту ISQL/w можно запустив загрузочный модуль
              isqlw.exe. Необходимыми динамическими библиотеками при работе утилиты являются:
              ntdblib.dll, sqlgui32.dll, sqlsvc32.dll и sqlqry32.dll.</P>
            <P align=justify>Кроме того, вызвать утилиту ISQL/w можно работая с
              интегрированной утилитой SQL Enterprise Manager. Для этого необходимо выбрать
              пункт Query Tool меню Tools.</P>
          </div>
        </div>
      </div>

      <H3 class="lab-subtitle">Описание задания</H3>

      <!--База данных книготорговой компании-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#data-base"
        >
          База данных книготорговой компании
        </h3>
        <div id="data-base" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Рассмотрим простую предметную область жизнедеятельности,
              связанную с книгоизданием и маркетингом. В рамках данной предметной области
              существуют издатели, которые публикуют книги, авторы, которые книги пишут, и
              издания (сами книги). Разработана база данных pubs, определяющая описанную выше
              предметную область. Инфологическая модель предметной области с использованием
              диаграмм “сущность-связь” (ER-диаграмм) [1], разработанных Ченом, представлена
              на рис. 1. </P>
            <P></P>
            <P align=justify>На данном рисунке прямоугольниками обозначены типы сущностей
              (объектов), а ромбами - типы связей между сущностями. Атрибуты сущностей указаны
              мелким шрифтом в том же прямоугольнике, который отображает типы сущностей. Имя
              типа сущности отмечено в верхней части прямоугольника жирным шрифтом. Атрибуты
              связей в данном случае обозначены овалами. Как видно из рис. 1 у связи
              “Написана” имеется два атрибута: первый атрибут определяет порядок автора в
              названии книги, второй атрибут - гонорар автора книги.</P>
            <P align=justify>
              <img class="img-center" src="images/schema.png" />
            </P>
            <P class="text-center">Рис. 1 - Инфологическая модель предметной области с использованием
              диаграмм “сущность-связь”</P>
            <P align=justify>База данных книготорговой компании (база данных pubs) включает
              три таблицы, определяющие сущности: таблица authors определяет авторов, таблица
              publishers - издателей, а таблица titles - сами книги. Четвертая таблица
              titleauthor задает отношение между таблицами titles и authors. Она показывает,
              какие авторы написали какие книги. Связь между таблицами titiles и publishers
              определяется столбцом pub_id в данных таблицах.</P>
            <P align=justify>Ниже представлены структуры используемых таблиц.</P>
            
            <P align=left><I><FONT size=+1>Структура таблицы authors</FONT></I></P>
            <TABLE class="data-table" cellSpacing=2 cellPadding=7>
              <thead>
                <tr>
                  <th vAlign=top width="18%">
                    <P align=justify>Имя столбца </P>
                  </th>
                  <th vAlign=top width="17%">
                    <P align=justify>Тип данных </P>
                  </th>
                  <th vAlign=top width="13%">
                    <P align=justify>Размерность </P>
                  </th>
                  <th vAlign=top width="14%">
                    <P align=justify>Возможность значений null </P>
                  </th>
                  <th vAlign=top width="37%">
                    <P align=left>Содержательное описание </P>
                  </th>
                </tr>
              </thead>
              <TBODY>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>au_id </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="13%">
                  <P align=justify>11 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="37%">
                  <P align=justify>Идентификатор автора </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>au_lname </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="13%">
                  <P align=justify>40 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="37%">
                  <P align=justify>Фамилия автора </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>au_fname </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="13%">
                  <P align=justify>20 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="37%">
                  <P align=justify>Имя автора </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>phone </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>char </P></TD>
                <TD vAlign=top width="13%">
                  <P align=justify>12 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="37%">
                  <P align=justify>Номер телефона </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>address </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="13%">
                  <P align=justify>40 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="37%">
                  <P align=justify>Адрес (улица, дом, квартира) </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>city </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="13%">
                  <P align=justify>20 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="37%">
                  <P align=justify>Город проживания </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>state </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>char </P></TD>
                <TD vAlign=top width="13%">
                  <P align=justify>2 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="37%">
                  <P align=justify>Штат проживания </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>zip </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>char </P></TD>
                <TD vAlign=top width="13%">
                  <P align=justify>5 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="37%">
                  <P align=justify>Энергичность </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>contract </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>bit </P></TD>
                <TD vAlign=top width="13%">
                  <P align=justify>1 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="37%">
                  <P align=justify>Наличие контракта </P></TD>
              </TR>
              </TBODY>
            </TABLE>
            
            <P align=left><I><FONT size=+1>Структура таблицы publishers</FONT></I></P>
            <TABLE class="data-table">
              <thead>
                <TR>
                  <th vAlign=top width="18%">
                    <P align=justify>Имя столбца </P></th>
                  <th vAlign=top width="17%">
                    <P align=justify>Тип данных </P></th>
                  <th vAlign=top width="8%">
                    <P align=justify>Размерность </P></th>
                  <th vAlign=top width="9%">
                    <P align=justify>Возможность значений null </P></th>
                  <th vAlign=top width="47%">
                    <P align=justify>Содержательное описание </P></th>
                </TR>
              </thead>
              <TBODY>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>pub_id </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>char </P></TD>
                <TD vAlign=top width="8%">
                  <P align=justify>4 </P></TD>
                <TD vAlign=top width="9%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="47%">
                  <P align=justify>Идентификатор издательства (издателя) </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>pub_name </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="8%">
                  <P align=justify>40 </P></TD>
                <TD vAlign=top width="9%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="47%">
                  <P align=justify>Название издательства (имя издателя) </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>city </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="8%">
                  <P align=justify>20 </P></TD>
                <TD vAlign=top width="9%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="47%">
                  <P align=justify>Город </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>state </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>char </P></TD>
                <TD vAlign=top width="8%">
                  <P align=justify>2 </P></TD>
                <TD vAlign=top width="9%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="47%">
                  <P align=justify>Штат </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>country </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="8%">
                  <P align=justify>30 </P></TD>
                <TD vAlign=top width="9%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="47%">
                  <P align=justify>Страна </P></TD>
              </TR>
              </TBODY>
            </TABLE>
            
            <P align=left><I><FONT size=+1>Структура таблицы titles</FONT></I></P>
            <TABLE class="data-table">
              <thead>
              <TR>
                <th vAlign=top width="18%">
                  <P align=justify>Имя столбца </P></th>
                <th vAlign=top width="17%">
                  <P align=justify>Тип данных </P></th>
                <th vAlign=top width="12%">
                  <P align=justify>Размерность </P></th>
                <th vAlign=top width="14%">
                  <P align=justify>Возможность значений null </P></th>
                <th vAlign=top width="39%">
                  <P align=justify>Содержательное описание </P></th>
              </TR>
              </thead>
              <TBODY>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>title_id </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>6 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="39%">
                  <P align=justify>Идентификатор книги </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>title </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>80 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="39%">
                  <P align=justify>Название книги </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>type </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>char </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>12 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="39%">
                  <P align=justify>Тип книги </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>pub_id </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>char </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>4 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="39%">
                  <P align=justify>Идентификатор издательства </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>price </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>money </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>8 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="39%">
                  <P align=justify>Цена </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>advance </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>money </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>8 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="39%">
                  <P align=justify>Аванс (стоимость предварительной продажи) </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>royalty </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>int </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>4 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="39%">
                  <P align=justify>Гонорар </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>ytd_sales </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>int </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>4 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="39%">
                  <P align=justify>Число книг, проданных в текущем году </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>notes </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>200 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="39%">
                  <P align=justify>Замечания </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="18%">
                  <P align=justify>pubdate </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>datetime </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>8 </P></TD>
                <TD vAlign=top width="14%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="39%">
                  <P align=justify>Дата опубликования </P></TD>
              </TR>
              </TBODY>
            </TABLE>
            
            <P align=left><I><FONT size=+1>Структура таблицы titleauthor</FONT></I></P>
            <TABLE class="data-table">
              <thead>
              <TR>
                <th vAlign=top width="17%">
                  <P align=justify>Имя столбца </P></th>
                <th vAlign=top width="17%">
                  <P align=justify>Тип данных </P></th>
                <th vAlign=top width="12%">
                  <P align=justify>Размерность </P></th>
                <th vAlign=top width="12%">
                  <P align=justify>Возможность значений null </P></th>
                <th vAlign=top width="42%">
                  <P align=justify>Содержательное описание </P></th>
              </TR>
              </thead>
              <TBODY>
              <TR>
                <TD vAlign=top width="17%">
                  <P align=justify>au_id </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>11 </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="42%">
                  <P align=justify>Идентификатор автора книги </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="17%">
                  <P align=justify>title_id </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>varchar </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>6 </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>Нет </P></TD>
                <TD vAlign=top width="42%">
                  <P align=justify>Идентификатор книги </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="17%">
                  <P align=justify>au_ord </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>tinyint </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>1 </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="42%">
                  <P align=justify>Порядок автора в названии книги </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="17%">
                  <P align=justify>royaltyper </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>int </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>4 </P></TD>
                <TD vAlign=top width="12%">
                  <P align=justify>Да </P></TD>
                <TD vAlign=top width="42%">
                  <P align=justify>Авторский гонорар </P></TD>
              </TR>
              </TBODY>
            </TABLE>
            
            <P align=justify>В столбце type таблицы titles используются следующие типы книг:
              business - книги по бизнесу, mod_cook - книги по современной кулинарии,
              popular_comp - книги по компьютерной тематике, psychology - книги по психологии,
              trad_cook - книги по традиционной кулинарии, UNDECIDED - неопределенный тип
              книги.</P>
            <P align=justify>В столбцах state таблиц authors и publishers используются
              следующие обозначения административных единиц США: CA - штат Калифорния, DC -
              округ Колумбия, IL - штат Иллинойс, IN - штат Индиана, KS -штат Канзас, MD -
              штат Мэриленд, MA - штат Массачусетс, MI - штат Мичиган, NY - штат Нью-Йорк, OR
              - штат Орегон, TN - штат Теннесси, TX - штатТехас, UT - штат Юта.</P>
            <P align=justify>В столбце country таблицы publishers используются следующие
              обозначения стран: France - Франция, Germany - Германия, USA - США.</P>
            <P align=justify>Домен городов, используемый в таблицах authors и publishers,
              включает города Ann Arbor, Berkeley, Boston, Chicago, Corvallis, Colevo, Dallas,
              Gary, Lawrence, Menlo Park, Munchen, Nashville, New York, Oakland, Palo Alto,
              Paris, Rockville, Salt Lake City, San Francisco, San Jose, Vacaville, Walnul
              Creek, Washington.</P>
            <P align=justify>В приложении 1 приведен полный пример базы данных pubs.</P>
          </div>
        </div>
      </div>
      <!--Лабораторные задания типа А-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#lab-job-A"
        >
          Лабораторные задания типа А
        </h3>
        <div id="lab-job-A" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Дать содержательную интерпретацию SQL-запросам, выполнить их на
              SQL-сервере с использованием клиентских утилит ISQL/w или SQL-EM, дать
              содержательную интерпретацию результатам выполнения SQL-запросов.</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    1)  SELECT au_lname, au_fname
        FROM authors

    2)  SELECT au_lname, au_fname
        FROM authors
        ORDER BY au_lname

    3)  SELECT au_lname, au_fname
          FROM authors
          ORDER BY au_lname, au_fname

    4)  SELECT title_id, price, ytd_sales, price*ytd_sales "ytd dollar sales"
        FROM titles
        ORDER BY price*ytd_sales

    5)  SELECT title_id, price, ytd_sales, price*ytd_sales "ytd dollar sales"
        FROM titles
        ORDER BY price*ytd_sales DESC

    6)  SELECT title_id, type, ytd_sales
        FROM titles
        ORDER BY type ASC, ytd_sales DESC

    7)  SELECT AVG(price)
        FROM titles

    8)  SELECT DISTINCT type
        FROM titles
        ORDER BY type ACS

    9)  SELECT DISTINCT city
        FROM authors
        ORDER BY city DESC

    10) SELECT DISTINCT state
        FROM authors
        ORDER BY state

    11) SELECT DISTINCT country
        FROM publishers
        ORDER BY country DESC

    12) SELECT AVG(price), AVG(DISTINCT price)
        FROM titles

    13) SELECT *
        FROM titles

    14) SELECT au_lname, au_fname
        FROM authors
        WHERE state= "CA"

    15) SELECT type, title_id, price
        FROM titles
        WHERE price*ytd_sales < advance

    16) SELECT au_id, city, state
        FROM authors
        WHERE state= "CA" OR city= "Palo Alto"

    17) SELECT title_id, price
        FROM titles
        WHERE price between $5 AND $15

    18) SELECT title_id, price
        FROM titles
        WHERE type IN ("mod_cook", "trad_cook", "business")

    19) SELECT au_lname, au_fname, city, state
        FROM authors
        WHERE city like "San%"

    20) SELECT type, title_id, price
        FROM titles
        WHERE title_id like "B_2075"

    21) SELECT type, title_id, price
        FROM titles
        WHERE title_id like "B[AUN]7832"

    22) SELECT AVG(price) "AVG"
        FROM titles
        WHERE type= "business"

    23) SELECT AVG(price) "avg" SUM(price) "sum"
        FROM titles
        WHERE type IN ("business", "mod_cook")

    24) SELECT COUNT(*)
        FROM authors
        WHERE state= "CA"

    25) SELECT COUNT(*)
        FROM titles
        WHERE LIKE "Co%s"

    26) SELECT title
        FROM titles
        WHERE ytd_sales IS NULL

    27) SELECT au_lname "Фамилия”, au_fname "Имя”
        FROM authors
        WHERE contract=1 AND phone LIKE "408____-__2_"

    28) SELECT phone
        FROM authors
        WHERE address LIKE "%Broadway Av.%"

    29) SELECT title, pubdate
        FROM titles
        WHERE pubdate>= "Jun 9 1991 12:00AM"
        AND pubdate< "6/16/91"

    30) SELECT type, AVG(price) "avg", SUM(price) "sum"
        FROM titles
        WHERE type IN ("business", "psychology")
        GROUP BY type

    31) SELECT type, pub_id, AVG(price) "avg", SUM(price) "sum"
        FROM titles
        WHERE type IN ("business", "mod_cook")
        GROUP BY type, pub_id

    32) SELECT type, AVG(price)
        FROM titles
        WHERE price>$11
        GROUP BY type
        HAVING AVG(price)>$19.7

    33) SELECT au_id, COUNT(*)
        FROM authors
        GROUP BY au_id
        HAVING COUNT(*)>1

    34) SELECT type, MIN(price), MAX(price)
        FROM titles
        GROP BY type
        ORDER BY type

    35) SELECT type, MIN(price), MAX(price)
        FROM titles
        GROUP BY type
        HAVING MAX(price)-MIN(price)>=3

    36) SELECT state, COUNT(DISTINCT pub_id)
        FROM publishers
        GROUP BY state

    37) SELECT pub_name, AVG(price) "avg",
        COUNT(DISTINCT title_id) "count"
        FROM titles t JOIN publishers p ON t.pub_id=p.pub_id
        GROUP BY pub_name

    38) SELECT type, (MIN(price)+MIN(price))/2, AVG(price)
        FROM titles
        GROUP BY type
        HAVING type<> "UNDECIDED"
        ORDER BY 2 DESC

    39) SELECT type, MIN(pubdate), MAX(pubdate)
        FROM titles
        GROUP BY type

    40) SELECT title, pub_name
        FROM titles CROSS JOIN publishers

    41) SELECT *
        FROM titles, publishers

    42) SELECT title, pub_name
        FROM titles, publishers
        WHERE titles.pub_id=publishers.pub_id

    43) SELECT title, pub_name
        FROM titles JOIN publishers
        ON titles.pub_id=publishers.pub_id

    44) SELECT *
        FROM titles t, publishers p
        WHERE t.pub_id=p.pub_id

    45) SELECT t.*, pub_name
        FROM titles t, publishers p
        WHERE t.pub_id=p.pub_id

    46) SELECT a.city, a.state
        FROM authors a, publishers p
        WHERE a.city=p.city AND a.state=p.state

    47) SELECT au_lname, au_fname
        FROM authors a JOIN titleauthor ON a.au_id=ta.au_id
        JOIN titles t ON ta.title_id=t.title_id
        WHERE au_lname LIKE "R%"
        AND state IN ("CA", "TX", "NY", "OR", "UT")
        AND (title LIKE "_h_ %" OR title LIKE "% _h_ %"
        OR title LIKE "% _h_")

    48) SELECT title, type
        FROM authors a, titles t, titleauthor ta, publishers p
        WHERE ta.title_id=t.title_id AND a.au_id=ta.au_id
        AND t.pub_id=p.pub_id AND p.city=a.city

    49) SELECT au_lname, au_fname, title
        FROM authors a, titles t, titleauthor ta, publishers p
        WHERE ta.title_id=t.title_id AND a.au_id=ta.au_id
        AND t.pub_id=p.pub_id
        AND ((p.country= ‘USA’ AND t.type=’popular_comp’)
        OR (p.country=’France’ AND t.type=’psychology’))

    50) SELECT au_lname, au_fname, city
        FROM authors a, titles t, titleauthor ta
        WHERE ta.title_id=t.title_id AND a.au_id=ta.au_id
        AND (city LIKE "[CPR]%" OR city LIKE "%San%")
        AND (title LIKE "% the %" OR title LIKE "The %"
        OR title LIKE "% a %" OR title LIKE "A %")

    51) SELECT DISTINCT au_lname, au_fname
        FROM authors a JOIN titleauthor ta ON a.au_id=ta.au_id
        JOIN titles t ON ta.title_id=t.title_id
        JOIN publishers p ON p.pub_id=t.pub_id
        WHERE p.state= "CA"
        ORDER BY au_lname, au_fname

    52) SELECT pub_name
        FROM publishers p JOIN titles t ON p.pub_id=t.pub_id WHERE $15>price AND type= "psychology"
        ORDER BY pub_name

    53) SELECT pub_name, AVG(price)
        FROM titles t, publishers p
        WHERE t.pub_id=p.pub_id
        GROUP BY pub_name

    54) SELECT pub_name, AVG(price)
        FROM titles t JOIN publishers p ON t.pub_id=p.pub_id
        GROUP BY pub_name

    55) SELECT au_lname, au_fname, title
        FROM authors a, titles t, titleauthor ta
        WHERE ta.title_id=t.title_id AND a.au_id=ta.au_id
        AND type= "popular_comp"

    56) SELECT au_lname, au_fname, title
        FROM authors a JOIN titleauthor ta ON a.au_id=ta.au_id
        JOIN titles t ON ta.title_id=t.title_id
        WHERE type= "psychology"

    57) SELECT au_lname, au_fname, pub_name, COUNT(*)
        FROM authors a, titles t, titleauthor ta, publishers p
        WHERE ta.title_id=t.title_id AND a.au_id=ta.au_id
        AND t.pub_id=p.pub_id
        GROUP BY au_lname, au_fname, pub_name

    58) SELECT MIN(price)
        FROM titles t, publishers p
        WHERE t.pub_id=p.pub_id
        GROUP BY country
        HAVING country=’USA’

    59) SELECT pub_name, COUNT(*)
        FROM titles t, publishers p
        WHERE t.pub_id=p.pub_id
        AND (type= ‘mod_cook’ OR type=’trad_cook’)
        GROUP BY pub_name

    60) SELECT pub_name, COUNT(*)
        FROM publishers p, titles t
        WHERE p.pub_id=t.pub_id AND price>$15
        GROUP BY pub_name
        ORDER BY pub_name DESC

    61) SELECT title, COUNT(DISTINCT a.au_id)
        FROM titles t JOIN titleauthor ta ON t.title_id=ta.title_id
        JOIN authors a ON ta.au_id=a.au_id
        JOIN publishers p ON p.pub_id=t.pub_id
        GROUP BY title

    62) SELECT state, COUNT(DISTINCT p.pub_id)
        FROM publishers p JOIN titles t ON p.pub_id=t.pub_id
        GROUP BY state

    63) SELECT title
        FROM titles
        WHERE pub_id=
        (SELECT pub_id
        FROM publishers
        WHERE pub_name= "Binnet & Hardley")

    64) SELECT pub_name
        FROM publishers
        WHERE pub_id IN
        (SELECT pub_id
        FROM titles
        WHERE type= "business")

    65) SELECT pub_name
        FROM publishers p
        WHERE EXISTS
        (SELECT *
        FROM titles t
        WHERE p.pub_id=t.pub_id
        AND type="popular_comp")

    66) SELECT pub_name
        FROM publishers p
        WHERE NOT EXISTS
        (SELECT *
        FROM titles t
        WHERE p.pub_id=t.pub_id
        AND type="mod_cook")

    67) SELECT pub_name
        FROM publishers
        WHERE pub_id NOT IN
        (SELECT pub_id
        FROM titles
        WHERE type="psychology")

    68) SELECT type, price
        FROM titles
        WHERE price < (SELECT AVG(price) FROM titles)

    69) SELECT type, AVG(price)
        FROM titles
        GROUP BY type
        HAVING AVG(price) < (SELECT AVG(price) FROM titles)

    70) SELECT DISTINCT a.city, a.state
        FROM authors a
        WHERE NOT EXISTS
        (SELECT *
        FROM publishers p
        WHERE a.city=p.city AND a.state=p.state)

    71) SELECT DISTINCT p.city, p.state
        FROM publishers p
        WHERE NOT EXISTS
        (SELECT *
        FROM authors a
        WHERE p.city=a.city AND p.state=a.state)

    72) SELECT MIN(price)
        FROM titles t
        WHERE t.pub_id IN
        (SELECT pub_id
        FROM publishers
        WHERE country=’USA’)

    73) SELECT title, type, price
        FROM titles
        WHERE price>ALL
        (SELECT price
        FROM titles
        WHERE type= "psychology")

    74) SELECT COUNT(DISTINCT city)
        FROM publishers
        WHERE pub_id IN
        (SELECT pub_id
        FROM titles
        WHERE type= "psychology")

    75) SELECT pub_name
        FROM publishers p
        WHERE 15>SOME
        (SELECT price
        FROM titles t
        WHERE p.pub_id=t.pub_id
        AND type= "trad_cook")

    76) SELECT pub_name, state
        FROM publishers
        WHERE pub_id NOT IN
        (SELECT pub_id
        FROM titles)

    77) SELECT title
        FROM titles
        WHERE pub_id NOT IN
        (SELECT pub_id
        FROM publishers)

    78) SELECT title
        FROM titles t
        WHERE price>=
        (SELECT AVG(price)
        FROM titles tt, publishers pp
        GROUP BY pub_id
        HAVING t.pub_id=pp.pub_id)

    79) SELECT au_lname, au_fname, price
        FROM authors a, titles t, titleauthor ta, publishers p
        WHERE ta.title_id=t.title_id AND a.au_id=ta.au_id
        AND t.pub_id=p.pub_id AND country=’USA’
        AND price=
        (SELECT MIN(price)
        FROM titles tt, publishers pp
        WHERE tt.pub_id=pp.pub_id
        GROUP BY country
        HAVING country=’USA’)

    80) SELECT DISTINCT au_lname, au_fname
        FROM authors a, titles t, titleauthor ta
        WHERE a.au_id=ta.au_id AND ta.title_id IN
        (SELECT title_id
        FROM titles
        WHERE ytd_sales=
        (SELECT MAX(ytd_sales)
        FROM titles))

    81) SELECT DISTINCT a.city, a.state
        FROM authors a
        WHERE NOT EXISTS
        (SELECT *
        FROM publishers p
        WHERE a.city=p.city AND a.state=p.state)
        UNION SELECT DISTINCT p.city, p.state
        FROM publishers p
        WHERE NOT EXISTS
        (SELECT *
        FROM authors a
        WHERE p.city=a.city AND p.state=a.state)

    82) SELECT title, price
        FROM titles t JOIN publishers p ON t.pub_id=p.pub_id
        WHERE p.country= "USA" AND t.price=
        (SELECT MAX(price)
        FROM titles tt JOIN publishers pp
        ON tt.pub_id=pp.pub_id
        WHERE country= "USA")

    83) SELECT pub_name, COUNT(*)
        FROM titles t, publishers p
        WHERE t.pub_id=p.pub_id
        GROUP BY pub_name
        HAVING COUNT(*)>=ALL
        (SELECT COUNT(*)
        FROM titles tt, publishers pp
        WHERE tt.pub.id=pp.pub_id
        GROUP BY pub_name)

    84) SELECT pub_name, city, state, country
        FROM publishers p
        WHERE EXISTS
        (SELECT *
        FROM titles t
        WHERE t.pub_id=p.pub_id)
        AND 20>ALL
        (SELECT price
        FROM titles t
        WHERE t.pub_id=p.pub_id
        AND price IS NOT NULL)

    85) SELECT state, SUM(price)
        FROM titles t, publishers p
        WHERE t.pub_id=p.pub_id
        GROUP BY state
        HAVING state NOT IN ("TN", "MA", "TX")
        AND SUM(price)>
        (SELECT SUM(price)
        FROM titles tt, publishers pp
        WHERE tt.pub.id=pp.pub_id
        AND pp.city= "Boston")

    86) SELECT pub_name, MIN(price)
        FROM titles t, publishers p
        WHERE t.pub_id=p.pub_id
        GROUP BY pub_name
        HAVING MIN(price)>=ALL
        (SELECT MIN(price)
        FROM titles tt JOIN publishers pp
        ON tt.pub_id=pp.pub_id
        GROUP BY pub_name)

    87) SELECT *
        FROM publishers
        WHERE pub_id IN
        (SELECT pub_id
        FROM titles
        WHERE type= "psychology" AND pub_id IN
        (SELECT pub_id
        FROM publishers
        WHERE country= "USA"
        AND state<> "CA")

    88) SELECT au_lname, au_fname
        FROM authors a
        WHERE a.au_id IN
        (SELECT au_id
        FROM titleauthor ta
        WHERE ta.title_id IN
        (SELECT title_id
        FROM titles t
        WHERE "CA"=SOME
        (SELECT state
        FROM publishers p
        WHERE p.pub_id=t.pub_id)))
        ORDER BY au_lname, au_fname

    89) SELECT state, COUNT(*)
        FROM publishers p
        WHERE EXISTS
        (SELECT *
        FROM titles t
        WHERE p.pub_id=t.pub_id)
        AND $22>ALL
        (SELECT price
        FROM titles t
        WHERE p.pub_id=t.pub_id
        AND price IS NOT NULL)
        GROUP BY state
        ORDER BY state ASC

    90) SELECT state
        FROM publishers p1
        GROUP BY state
        HAVING COUNT(DISTINCT pub_name)=
        (SELECT COUNT(*)
        FROM publishers p2
        WHERE EXISTS
        (SELECT *
        FROM titles t
        WHERE p2.pub_id=t.pub_id)
        AND $22.5>ALL
        (SELECT price
        FROM titles t
        WHERE p2.pub_id=t.pub_id
        AND price IS NOT NULL)
        GROUP BY state
        HAVING p1.state=p2.state)

    91) SELECT p1.pub_id
        FROM titles t1, publishers p1
        WHERE t1.pub_id=p1.pub_id
        GROUP BY p1.pub_id
        HAVING COUNT(DISTINCT title)=
        (SELECT COUNT(*)
        FROM titles t2
        WHERE t2.pub_id=p1.pub_id
        AND EXISTS
        (SELECT *
        FROM titleauthor ta3, authors a3
        WHERE ta3.au_id=a3.au_id
        AND ta3.title_id=t2.title_id
        AND a3.state IN
        (SELECT state
        FROM publishers p4
        WHERE "business"=SOME
        (SELECT type
        FROM titles t5
        WHERE p4.pub_id=
        t5.pub_id))))

    92) SELECT city, state
        FROM authors
        UNION SELECT city, state
        FROM publishers
        ORDER BY state, sity

    93) SELECT city
        FROM authors
        UNION SELECT city
        FROM publishers

    94) SELECT state
        FROM authors
        UNION SELECT state
        FROM publishers

    95) SELECT city, state
        FROM authors
        WHERE state IS NOT NULL
        UNION SELECT city, state
        FROM publishers
        WHERE state IS NOT NULL
        ORDER BY city DESC, state ASC

    96) SELECT state, MIN(price), MAX(price), AVG(price)
        FROM authors a, titles t, titleauthor ta
        WHERE ta.title_id=t.title_id AND a.au_id=ta.au_id
        GROUP BY state
        HAVING state<> "CA"


  </code>
            </pre>
          </div>
        </div>
      </div>
      <!--Лабораторные задания типа B-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#lab-job-B"
        >
          Лабораторные задания типа B
        </h3>
        <div id="lab-job-B" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Составить SQL-запросы по их заданному содержательному описанию,
              выполнить SQL-запросы на SQL-сервере с использованием клиентских утилит ISQL/w
              или SQL-EM, проинтерпретировать результаты выполнения запросов.</P>
            <P align=justify>1) Выбрать имена и фамилии авторов книг.</P>
            <P align=justify>2) Выбрать имена и фамилии авторов, проживающих в
              Калифорнии.</P>
            <P align=justify>3) Выбрать информацию о книгах, объеме (стоимость) продаж
              которых в текущем году меньше стоимости предварительной продажи. Информация о
              книгах должна включать тип книги, идентификатор и цену книги.</P>
            <P align=justify>4) Выбрать информацию об авторах, проживающих в штате
              Калифорния или в городе Salt Lake City. Информация об авторах должна включать
              идентификатор автора, город и штат проживания.</P>
            <P align=justify>5) Выбрать все идентификаторы и цены книг, причем цена книги
              должна лежать в диапазоне от 5 до 10 долларов. В SQL запросе использовать
              предикат BETWEEN.</P>
            <P align=justify>6) Выбрать все идентификаторы и цены книг по современной и
              традиционной кулинарии и по бизнесу. В запросе использовать предикат IN. </P>
            <P align=justify>7) Выбрать информацию об авторах, проживающих в городах,
              название которых начинается со строки "spring". Информация об авторах должна
              включать имя и фамилию автора, а также штат и город проживания.</P>
            <P align=justify>8) Выбрать информацию о книгах, идентификаторы которых
              начинаются буквой "B", а кончаются строкой "1342". Информация о книгах должна
              включать тип, идентификатор и цену книги.</P>
            <P align=justify>9) Выбрать информацию о книгах, идентификаторы которых
              начинаются буквой "B", заканчиваются строкой "1342", а вторым символом
              идентификатора являются буквы "A", "U" или "N". Информация о книгах должна
              включать тип, идентификатор и цену книги.</P>
            <P align=justify>10) Выбрать имена и фамилии всех авторов, упорядоченные по
              возрастанию фамилий авторов.</P>
            <P align=justify>11) Выбрать имена и фамилии всех авторов, упорядоченные в
              первую очередь по возрастанию фамилий и, во вторую очередь, по возрастанию
              имен.</P>
            <P align=justify>12) Выбрать информацию о книгах, упорядоченную по возрастанию
              объема продаж (по стоимости). Информация о книгах должна включать идентификатор,
              цену, объем продаж (по количеству) и объем продаж (по стоимости).</P>
            <P align=justify>13) То же, что 12, но использовать упорядочение по
              убыванию.</P>
            <P align=justify>14) Выбрать информацию о всех книгах, упорядоченную по убыванию
              типа книги и числа проданных книг. Информация о книгах должна включать
              идентификатор и тип книги, а также число проданных книг.</P>
            <P align=justify>15) Определить среднюю цену книги.</P>
            <P align=justify>16) Определить среднюю цену книг по бизнесу.</P>
            <P align=justify>17) Определить среднюю цену и стоимость всех книг по бизнесу и
              современной кулинарии</P>
            <P align=justify>18) Определить число авторов, проживающих в Калифорнии.</P>
            <P align=justify>19) Определить среднюю цену и сумму цен на книги по бизнесу и
              современной кулинарии отдельно для каждого типа книги.</P>
            <P align=justify>20) Определить среднюю цену и сумму цен на книги по бизнесу и
              современной кулинарии для каждой комбинации типа книги и идентификатора
              издателя.</P>
            <P align=justify>21) Выбрать те типы книг, средняя цена дорогих экземпляров
              (стоимостью более 10 долларов) которых превышает 20 долларов. В выбираемые
              данные помимо типа книги включить и среднюю цену дорогих экземпляров.</P>
            <P align=justify>22) Подсчитать число строк в таблице authors, включающих
              одинаковые идентификаторы авторов. В выбираемые данные включить идентификатор
              автора и соответствующее ему число повторяющихся строк.</P>
            <P align=justify>23) Выбрать названия книг и имена выпустивших их издателей.</P>
            <P align=justify>24) То же, что и 23, но в разделе FROM запроса использовать
              операцию соединения JOIN.</P>
            <P align=justify>25) Произвести проекцию на столбцы title и pub_name декартова
              произведения таблиц titles и publishers.</P>
            <P align=justify>26) Определить среднюю цену выпускаемых каждым издателем книг.
              В выбираемые данные включить имя издателя и среднюю цену книги.</P>
            <P align=justify>27) То же, что и 26, но в разделе FROM запроса использовать
              операцию соединения JOIN.</P>
            <P align=justify>28) Определить, кто из авторов написал какую книгу по
              психологии. В выбираемые данные включить имя и фамилию автора, а также название
              книги.</P>
            <P align=justify>29) То же, что и 28, но в разделе FROM запроса использовать
              операцию соединению JOIN.</P>
            <P align=justify>30) Выбрать все столбцы результата эквисоединения таблиц titles
              publishers по идентификатору издателя.</P>
            <P align=justify>31) Выбрать все столбцы таблицы titles и столбец pub_name
              таблицы publishers результата эквисоединения данных таблиц по идентификатору
              издателя.</P>
            <P align=justify>32) Выбрать все книги издательства Algodata Infosysytems. В
              запросе использовать подзапрос для определения нужного идентификатора издателя.
              В условии поиска использовать предикат "=". В выбираемые данные включить
              название книги.</P>
            <P align=justify>33) Выбрать всех издателей литературы по бизнесу. В запросе
              использовать подзапрос для выборки нужных идентификаторов издателей. В условии
              поиска использовать предикат IN. В выбираемые данные включить имя издателя.</P>
            <P align=justify>34) Выбрать всех издателей литературы по бизнесу. В запросе
              использовать подзапрос, формирующий промежуточную таблицу, в которую включаются
              те строки из таблицы titles, которые могут “экви-соединиться” по идентификатору
              издателя со строками из таблицы publishers и которые представляют тип книг по
              бизнесу. В условии поиска основного запроса использовать предикат EXISTS. В
              выбираемые данные включить имя издателя.</P>
            <P align=justify>35) Выбрать издателей, не выпускающих книг по бизнесу.
              Дополнительные условия формирования запроса взять из варианта 34.</P>
            <P align=justify>36) Выбрать издателей, не выпускающих книг по бизнесу.
              Дополнительные условия формирования запроса взять из варианта 33.</P>
            <P align=justify>37) Выбрать тип и цену для всех книг, цена которых не превышает
              средней. В запросе использовать подзапрос, определяющий среднюю цену книг.</P>
            <P align=justify>38) Выбрать тип и среднюю цену книг данного типа, причем эта
              средняя цена должна быть меньше средней цены всех книг. В запросе использовать
              подзапрос, определяющий среднюю цену всех книг.</P>
            <P align=justify>39) Определить города и штаты проживания каждого из авторов и
              издателей в виде одной результирующей таблицы.</P>
            <P align=justify>40) Определить все типы книг. Типы книг в результирующей
              таблице не должны повторяться. Вывести типы книг в порядке возрастания.</P>
            <P align=justify>41) Определить все города, в которых проживают авторы. Названия
              городов в результирующей таблице не должны повторяться. Вывести названия городов
              в порядке убывания.</P>
            <P align=justify>42) Определить все штаты, в которых проживают авторы. Названия
              штатов в результирующей таблице не должны повторяться. Вывести названия штатов в
              порядке возрастания.</P>
            <P align=justify>43) Определить страны, в которых расположены издательства книг.
              Названия стран в результирующей таблице не должны повторяться. Вывести названия
              стран в порядке убывания.</P>
            <P align=justify>44) Определить все города, в которых проживают авторы и
              находятся издательства. Названия городов в результирующей таблице не должны
              повторяться. Вывести названия городов в порядке возрастания.</P>
            <P align=justify>45) Определить все штаты, в которых проживают авторы и
              находятся издательства. Названия штатов в результирующей таблице не должны
              повторяться. Вывести названия штатов в порядке убывания.</P>
            <P align=justify>46) Определить города и штаты совместного проживания авторов и
              издателей. (В запросе неявно реализуется операцию пересечения).</P>
            <P align=justify>47) Определить города и штаты проживания авторов, в которых нет
              издательств. (В запросе неявно реализуется операция разности).</P>
            <P align=justify>48) Определить города и штаты нахождения издательств, в которых
              не проживают авторы. (В запросе неявно реализуется операция разности).</P>
            <P align=justify>49) Определить, какой город в каком штате находится. Вывести
              названия городов в порядке возрастания.</P>
            <P align=justify>50) Определить число книг, название которых начинается со
              строки "The" и заканчивается буквой "e".</P>
            <P align=justify>51) Определить авторов на букву "G", проживающих в штатах
              Теннесси, Иллинойс, Канзас, Орегон или Калифорния, которые опубликовали книги, в
              которых есть слово из трех букв, причем средней буквой является буква "a".</P>
            <P align=justify>52) Определить минимальную, максимальную и среднюю цену для
              каждого из типов книг. Выводимые данные должны быть упорядочены по убыванию типа
              книг.</P>
            <P align=justify>53) Определить минимальную и максимальную цену для каждого из
              типов книг. В результирующую таблицу не включать те типы книг, для которых
              разность между максимальной и средней ценой меньше 7 долларов.</P>
            <P align=justify>54) Вычислить среднюю цену всех книг и медиану цены. Под
              медианой понимается среднее значение всех различных цен всех книг.</P>
            <P align=justify>55) Определить, какие авторы в каких издательствах опубликовали
              сколько книг.</P>
            <P align=justify>56) Определить книги, авторы и издатели которых живут в одном
              городе.</P>
            <P align=justify>57) Определить для каждого штата минимальную, максимальную и
              среднюю цену книг авторов, проживающих в одном штате (кроме штата
              Калифорния).</P>
            <P align=justify>58) Определить, какие авторы опубликовали какие книги в США по
              традиционной кулинарии или в Германии по компьютерам.</P>
            <P align=justify>59) Найти цену самой дешевой книги (книг), вышедшей в США. В
              запросе использовать операцию группирования.</P>
            <P align=justify>60) Найти авторов самых дорогих книг, вышедших в США. В запросе
              использовать подзапрос и операцию группирования.</P>
            <P align=justify>61) Найти авторов, у которых вышли самые нераспродаваемые
              книги.</P>
            <P align=justify>62) Найти цену самой дорогой книги (книг), вышедшей в США. В
              запросе использовать подзапрос.</P>
            <P align=justify>63) Определить число книг по компьютерам, выпущенных каждым
              издательством.</P>
            <P align=justify>64) Определить авторов из городов, начинающихся с букв "A", "B"
              или "C" или имеющих в своем составе слово "Salt", и написавших книги, в названии
              которых есть определенный или неопределенный артикль английского языка.</P>
            <P align=justify>65) Определить города и штаты проживания авторов и издателей,
              за исключением городов и штатов их совместного проживания. (В запросе неявно
              реализуется операция симметрической разности). </P>
            <P align=justify>66) Определить названия и цену самых дешевых книг, вышедших в
              США. (Самые дешевые книги имеют минимальную цену).</P>
            <P align=justify>67) Определить издательство, в котором опубликовано меньше
              всего книг.</P>
            <P align=justify>68) Найти книги, цена которых меньше цены каждой из книг по
              традиционной кулинарии.</P>
            <P align=justify>69) Определить местонахождение издательств, цена каждой книги
              которых меньше 22 долларов. В запросе использовать подзапросы и предикат с
              квантором.</P>
            <P align=justify>70) Определить штаты (кроме штатов Индиана, Канзас, Юта), в
              которых сумма цен выпущенных в них книг больше суммы цен книг, выпущенных в
              городе Вашингтон.</P>
            <P align=justify>71) Найти издательство, выпустившее свою самую дорогую книгу с
              наиболее низкой ценой среди всех издательств. В запросе использовать подзапрос,
              определяющий максимальные цены книг, выпущенные каждым издательством.</P>
            <P align=justify>72) Определить полную информацию об издателях книг по
              компьютерам, авторы которых живут в США (за исключением штата Юта). В запросе
              использовать подзапросы.</P>
            <P align=justify>73) Определить книги, стоимости которых составляют не более
              средней стоимости по издательству, где издавались эти книги.</P>
            <P align=justify>74) Определить для каждого штата число находящихся в нем
              издательств.</P>
            <P align=justify>75) Определить число городов, в которых выпускается литература
              по компьютерам. В запросе использовать подзапрос.</P>
            <P align=justify>76) Определить авторов, хотя бы одна книга которых была
              опубликована в штате Массачусетс. В запросе использовать подзапросы и предикат с
              квантором.</P>
            <P align=justify>77) Найти издательства, среди изданных книг которых найдется
              хоть одна книга по компьютерам стоимостью более двух долларов. В запросе
              использовать подзапрос и предикат с квантором.</P>
            <P align=justify>78) Определить штаты, во <U>всех</U> издательствах которых все
              изданные книги имеют цену более 10 долларов. В запросе использовать подзапросы и
              предикат с квантором.</P>
            <P align=justify>79) Определить издательства, для каждой книги которых
              выполняется условие: “Если книга выпущена в данном издательстве, то хотя бы один
              из авторов книги проживает в штате, в котором находится издательство, некоторые
              выпущенные книги которого посвящены компьютерам”.</P>
            <P align=justify>80) Выбрать все столбцы таблицы titles.</P>
            <P align=justify>81) Выбрать все столбцы декартова произведения таблиц titles и
              publishers.</P>
            <P align=justify>82) Определить книги, число продаж для которых
              неопределено.</P>
            <P align=justify>83) Определить минимальную и максимальную цену книг, выпущенных
              издательствами.</P>
            <P align=justify>84) Определить авторов, хотя бы одна книга которых была
              опубликована в штате Массачусетс. В запросе не использовать предикаты с
              квантором.</P>
            <P align=justify>85) Найти издательства, среди изданных книг которых найдется
              хоть одна книга по традиционной кулинарии стоимостью от 12 до 16 долларов. В
              запросе не использовать предикаты с квантором.</P>
            <P align=justify>86) Определить для каждого издательства число изданных им
              дешевых книг (ценой менее 13 долларов).</P>
            <P align=justify>87) Определить для штатов число издательств, в которых
              выпускаются только книги ценой более 7 долларов. В запросе использовать
              подзапросы и предикат с квантором.</P>
            <P align=justify>88) Определить, сколько авторов имеет каждая <U>изданная</U>
              книга.</P>
            <P align=justify>89) Определить штаты и число находящихся в них издательств,
              <U>выпустивших</U> книги.</P>
            <P align=justify>90) Определить издательства, не выпустившие книг.</P>
            <P align=justify>91) Определить неопубликованные в издательствах книги.</P>
            <P align=justify>92) Определить авторов, работающих по контракту и имеющих
              телефон с кодом города 415 (первые три цифры номера телефона).</P>
            <P align=justify>93) Определить номера телефонов авторов, проживающих на Седьмой
              Авеню (<I>Seventh Av</I>.)</P>
            <P align=justify>94) Определить книги, выпущенные в период с 1 июля 1991 г. по
              30 октября 1991 г. (По умолчанию сервер работает с датами в формате
              <I>xx/yy/zz</I> как с последовательностями <I>месяц/день/год</I>).</P>
            <P align=justify>95) Вычислить для каждого типа книг среднее арифметическое
              минимальной и максимальной цены. Результат упорядочить по убыванию значений.</P>
            <P align=justify>96) Определить временные интервалы, в рамках которых
              опубликованы книги разных типов.</P>
            <P align=justify>
              <I><B>Примечания:</B></I>
            <p>
              1. При упорядочении фамилий и имен
              авторов, городов, штатов, типов книг используется лексикографический порядок.
            </p>
            <p>
              2. “Издатель” и “издательство” являются в данном случае синонимами. Соответственно
              этому синонимами являются “имя издателя” и “название издательства”.
            </p>
            </P>
          </div>
        </div>
      </div>
      <!--Варианты лабораторных заданий-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#laboratory-tasks"
        >
          Варианты лабораторных заданий
        </h3>
        <div id="laboratory-tasks" class="accordion-body collapse">
          <div class="accordion-inner">
            <TABLE class="data-table">
              <thead>
                <TR>
                  <th vAlign=top width="27%">
                    <P align=left>Номер варианта </P></th>
                  <th vAlign=top width="36%">
                    <P align=left>Задание типа A </P></th>
                  <th vAlign=top width="36%">
                    <P align=left>Задание типа B </P></th>
                </TR>
              </thead>
              <TBODY>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>1 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>1,13,25,32,49,73,81,96 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>9,25,29,31,42,53,66,77 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>2 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>2,14,26,38,50,62,63,86 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>8,28,30,41,48,49,52,60 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>3 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>3,15,27,39,51,61,64,90 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>7,20,26,40,45,47,61,85 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>4 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>4,16,28,37,46,59,65,91 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>17,27,54,56,70,72,75,86 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>5 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>5,17,29,41,57,66,84,92 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>15,18,24,38,73,74,87,90 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>6 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>6,18,30,42,58,67,83,93 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>16,22,37,43,51,62,76,91 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>7 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>8,19,31,52,53,70,80,94 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>3,11,33,78,84,88,92,96 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>8 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>9,20,34,44,55,71,79,95 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>2,10,32,64,71,82,89,95 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>9 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>10,21,35,40,45,56,75,82 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>1,21,50,57,58,65,68,80 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>10 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>11,22,33,47,68,72,77,88 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>6,14,19,23,36,44,59,67 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>11 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>7,24,36,43,69,76,78,89 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>5,13,35,39,55,69,81,94 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="27%">
                  <P align=left>12 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>12,23,48,54,60,74,85,87 </P></TD>
                <TD vAlign=top width="36%">
                  <P align=justify>4,12,34,46,63,79,83,93
                  </P></TD>
              </TR>
              </TBODY>
            </TABLE>
          </div>
        </div>
      </div>
    </div>

    <div id="lab-2-content" class="content-lab" >

      <h2 class="lab-title">Лабораторная работа №2</h2>
      <h3 class="lab-title">Создание, модификация и удаление объектов базы
        данных с использованием SQL</h3>
      <P class="lab-subtitle"><B>Цель работы:</B> изучить языки определения и
        манипулирования данными SQL, получить практические навыки составления
        SQL-запросов для работы с таблицами, индексами, представлениями и курсорами, а
        также их выполнения на SQL-сервере с использованием клиентских утилит.</P>


      <H3 align=left><I>Порядок выполнения работы</I></H3>
      <H3 align=left><I>Изучение языка баз данных</I></H3>
      <ol class="numbered-list lab-subtitle">
        <li>Изучить язык определения данных SQL, включая операторы
          создания таблиц (CREATE TABLE), создания представлений (CREATE VIEW),
          модификации таблиц (ALTER TABLE), удаления таблиц (DROP TABLE), удаления
          представлений (DROP VIEW), а также операторы создания индексов (CREATE INDEX) и
          удаления индексов (DROP INDEX). Изучить типы ограничений и способы их
          представления на языке SQL.</li>
        <li>Изучить операторы манипулирования данными, связанные с
          курсором, включая оператор объявления курсора (DECLARE CURSOR), оператор
          открытия курсора (OPEN), оператор чтения очередной строки курсора (FETCH),
          оператор позиционного удаления (DELETE), оператор позиционной модификации
          (UPDATE), оператор закрытия курсора (CLOSE).</li>
        <li>Изучить одиночные операторы манипулирования данными,
          включая) операторы поискового удаления (DELETE) и поисковой модификации
          (UPDATE), а также оператор включения (INSERT).</li>
        <li>Изучить интегрированную утилиту SQL Enterprise Manager, а
          также системные хранимые процедуры с точки зрения их использования для просмотра
          объектов базы данных, создания и удаления таблиц. В частности, изучить работу с
          системной хранимой процедурой sp_help, используемой для получения информации о
          базе данных и объектах базы данных.</li>
      </ol>

      <h3><I>Работа непосредственно с таблицей</I></h3>
      <ol class="numbered-list lab-subtitle">
        <li>В соответствии с вариантом задания разработать точную
          структуру строк (записей) таблицы, включая выбор типов данных для каждого поля
          строки.</li>
        <li>Составить оператор создания таблицы с учетом приведенных в
          задании ограничений, выполнить данный оператор на SQL-сервере с использованием
          клиентской утилиты. Просмотреть результат выполнения данного оператора с помощью
          системной хранимой процедуры sp_help или клиентской утилиты SQL-EM.</li>
        <li>Заполнить созданную таблицу данными с использованием
          оператора включения. Просмотреть заполненную таблицу.</li>
        <li>Изменить одну или несколько строк таблицы с использованием
          оператора поисковой модификации. Просмотреть измененную таблицу.</li>
        <li>Удалить одну или несколько строк из таблицы с использованием
          оператора поискового удаления. Просмотреть измененную таблицу.</li>
        <li>Добавить столбец в таблицу с использованием оператора
          модификации таблицы. Просмотреть измененную таблицу.</li>
        <li>Удалить ограничение из таблицы с использованием оператора
          модификации таблицы. Просмотреть результат выполнения оператора.</li>
      </ol>

      <h3><I>Работа с курсором</I></h3>
      <ol class="numbered-list lab-subtitle">
        <li>Объявить скроллируемый курсор в соответствии со
          спецификацией курсора из лабораторного задания.</li>
        <li>Открыть курсор.</li>
        <li>Просмотреть первую, j-ю и последнюю строки результирующей
          таблицы, а также последовательно всю результирующую таблицу от начала и до конца
          и от конца до начала (число j задается преподавателем).</li>
        <li>Удалить n-ю строку результирующей таблицы с использованием
          оператора позиционного удаления (число n задается преподавателем). Просмотреть
          базовую таблицу и сравнить ее c предыдущим вариантом.</li>
        <li>Модифицировать k-ю строку результирующей таблицы, изменив
          значение одного или нескольких полей, с использованием оператора позиционной
          модификации (число k задается преподавателем). Просмотреть базовую таблицу и
          сравнить ее c предыдущим вариантом.</li>
        <li>Закрыть курсор.</li>
      </ol>

      <h3><I>Работа с представлением</I></h3>
      <ol class="numbered-list lab-subtitle">
        <li>В соответствии с заданием составить оператор создания
          представления, выполнить данный оператор на SQL-сервере с использованием
          клиентской утилиты. Просмотреть результат выполнения данного оператора с помощью
          системной хранимой процедуры sp_help или клиентской утилиты SQL-EM. Просмотреть
          представляемую таблицу.</li>
        <li>Включить несколько записей в представляемую таблицу с
          использованием оператора включения. Просмотреть представляемую и базовую таблицы
          и сравнить их с предыдущими вариантами этих таблиц.</li>
        <li>Изменить несколько строк представляемой таблицы с
          использованием оператора поисковой модификации. Просмотреть представляемую и
          базовую таблицы и сравнить их с предыдущими вариантами этих таблиц.</li>
        <li>Удалить несколько строк из представляемой таблицы с
          использованием оператора поискового удаления. Просмотреть представляемую и
          базовую таблицы и сравнить их с предыдущими вариантами этих таблиц.</li>
        <li>Удалить представление с использованием оператора удаления
          представления.</li>
      </ol>

      <h3><I>Работа с индексами</I></h3>
      <ol class="numbered-list lab-subtitle">
        <li>Создать индекс, который бы позволял быстрый поиск по
          первичному ключу, содержащему столбцы уникальности.</li>
        <li>Составить и выполнить какой-нибудь запрос к индексированной
          таблице.</li>
        <li>Удалить индекс.</li>
        <li>Удалить базовую таблицу с использованием оператора удаления
          таблицы.</li>
      </ol>

      <h3><B>Содержание отчета</B></h3>
      <OL class="numbered-list lab-subtitle">
        <LI>Задание;
        <LI value=2>Операторы создания и удаления таблицы;
        <LI>Операторы создания и удаления представления;
        <LI>Операторы объявления и закрытия курсора;
        <LI>Операторы создания и удаления индекса;
        <LI>Операторы манипулирования данными, относящиеся к базовой, представляемой и
          результирующей таблицам;
        <LI>Исходная базовая таблица;
        <LI>Исходная представляемая таблица;
        <LI>Исходная результирующая таблица курсора;
        <LI>Измененные таблицы (базовая, представляемая и результирующая) и ссылки на
          соответствующие им операторы изменения таблиц (для каждого акта изменения).
        </LI>
      </OL>
      <!--Типы данных Transact-SQL-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#type-data-sql"
        >
          Типы данных Transact-SQL
        </h3>
        <div id="type-data-sql" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=left><U><FONT size=+1>Символьные типы данных</FONT></U></P>
            <UL>
              <LI>CHAR[(n)] - cтроки фиксированной длины, где n - число символов в строке;
              <LI>VARCHAR[(n)] - строки переменной длины , где n - максимальное число
                символов в строке;
              <LI>TEXT - строки потенциально неограниченного размера (до 2 Гб текста в
                строке).
              </LI>
            </UL>

            <P align=justify>В данном случае 1? n? 255. Символьные столбцы, допускающие
              пустые значения (NULL), хранятся как столбцы переменной длины. </P>
            <P align=justify>Примеры определений столбцов и типов данных:</P>
            <ul>
              <li>name VARCHAR(40)</li>
              <li>state CHAR(2)</li>
              <li>description CHAR(50) NULL</li>
            </ul>
            <P align=left><U><FONT size=+1>Двоичные типы данных</FONT></U></P>
            <UL>
              <LI>BINARY(n) - двоичные строки фиксированной длины, где n - число двоичных
                символов в строке;
              <LI>VARBINARY(n) - двоичные строки переменной длины, где n - максимальное
                число двоичных символов в строке;
              <LI>IMAGE - большие двоичные строки (изображения до 2 Гб в строке).</LI>
            </UL>
            <P align=justify>В данном случае 1? n? 255. </P>
            <P align=justify>Пример задания двоичного столбца:</P>
            <p class="indent-left">bin_column BINARY(4) NOT NULL</p>
            
            <P align=left><U><FONT size=+1>Типы данных даты</FONT></U></P>
            <P align=justify>SQL Server поддерживает два типа обозначения даты и времени при
              хранении: DATETIME и SMALLDATETIME. Последний менее точный и охватывает меньший
              диапазон дат, но зато позволяет экономить место на диске.</P>
            <P align=justify>SQL Server поддерживает различные форматы ввода даты. По
              умолчанию он работает с датами в формате xx/yy/zz как с последовательностями
              месяц/день/год. Точность представления времени при использовании DATETIME - 3
              миллисекунды, а при использовании SMALLDATETIME - 1 минута. Пример:</P>
            
            <P class="indent-left">Формат ввода: 4/15/99</P>
            <P class="indent-left">Значение DATETIME: Apr 15 1999 12:00:00:000 AM</P>
            <P class="indent-left">Значение SMALLDATETIME: Apr 15 1999 12:00 AM</P>
            
            <P align=left><U><FONT size=+1>Логический тип данных</FONT></U></P>
            <P align=justify>SQL Server поддерживает логический тип данных BIT для столбцов
              флагов, имеющих значение 1 или 0.</P>
            
            <P align=left><FONT size=4><U><FONT size=+1>Числовые типы
              данных</FONT></U></FONT></P>
            <P align=justify>Числовые типы данных разбиваются на четыре основные
              категории:</P>
            <UL>
              <LI>целые, включающие INT, SMALLINT и TINYINT.
              <LI>данные с плавающей точкой, включающие FLOAT и REAL.
              <LI>данные с фиксированной точкой - NUMERIC и DECIMAL
              <LI>денежные типы данных - MONEY и SMALLMONEY.</LI>
            </UL>
            
            <P align=left><I><U><FONT size=+1>Целые типы данных</FONT></U></I></P>
            <TABLE width=471 class="data-table">
              <thead>
                <TR>
                  <th vAlign=top width="44%">
                    <P align=justify>Характеристика </P></th>
                  <th vAlign=top width="17%">
                    <P align=justify>INT </P></th>
                  <th vAlign=top width="21%">
                    <P align=justify>SMALLINT </P></th>
                  <th vAlign=top width="18%">
                    <P align=justify>TINYINT </P></th>
                </TR>
              </thead>
              <TBODY>
              <TR>
                <TD vAlign=top width="44%">
                  <P align=justify>Минимальное значение </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>-2 </P></TD>
                <TD vAlign=top width="21%">&nbsp;</TD>
                <TD vAlign=top width="18%">
                  <P align=justify>0 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="44%">
                  <P align=justify>Максимальное значение </P></TD>
                <TD vAlign=top width="17%">&nbsp;</TD>
                <TD vAlign=top width="21%">&nbsp;</TD>
                <TD vAlign=top width="18%">
                  <P align=justify>255 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="44%">
                  <P align=justify>Объем памяти </P></TD>
                <TD vAlign=top width="17%">
                  <P align=justify>4 байта </P></TD>
                <TD vAlign=top width="21%">
                  <P align=justify>2 байта </P></TD>
                <TD vAlign=top width="18%">
                  <P align=justify>1 байт </P></TD>
              </TR>
              </TBODY>
            </TABLE>
            
            <P align=left><U><FONT size=4><I><FONT size=+1>Типы данных с плавающей
              точкой</FONT></I></FONT></U></P>
            <TABLE class="data-table" width=565 >
              <thead>
                <TR>
                  <th vAlign=top width="36%">
                    <P align=justify>Характеристика </P></th>
                  <th vAlign=top width="33%">
                    <P align=justify>FLOAT </P></th>
                  <th vAlign=top width="31%">
                    <P align=justify>REAL </P></th>
                </TR>
              </thead>
              <TBODY>
              <TR>
                <TD vAlign=top width="36%">
                  <P align=justify>Минимальное значение </P></TD>
                <TD vAlign=top width="33%">
                  <P align=justify><FONT size=4>± </FONT>2.23E-308 </P></TD>
                <TD vAlign=top width="31%">
                  <P align=justify><FONT size=4>± </FONT>1.18E-38 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="36%">
                  <P align=justify>Максимальное значение </P></TD>
                <TD vAlign=top width="33%">
                  <P align=justify><FONT size=4>± </FONT>1.79E308 </P></TD>
                <TD vAlign=top width="31%">
                  <P align=justify><FONT size=4>± </FONT>3.40E38 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="36%">
                  <P align=justify>Точность </P></TD>
                <TD vAlign=top width="33%">
                  <P align=justify>до 15 значащих цифр </P></TD>
                <TD vAlign=top width="31%">
                  <P align=justify>до 7 значащих цифр </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="36%">
                  <P align=justify>Объем памяти </P></TD>
                <TD vAlign=top width="33%">
                  <P align=justify>8 байтов </P></TD>
                <TD vAlign=top width="31%">4 байта</TD>
              </TR>
              </TBODY>
            </TABLE>
            <P align=justify>Спецификатор типа FLOAT имеет вид FLOAT[(p)], где p -
              точность.</P>
            
            <P align=left><FONT size=4><I><U><FONT size=+1>Точные числовые типы
              данных</FONT></U></I></FONT></P>
            <P align=justify>Эти типы данных вводится описателями DECIMAL[(p,s)] и
              NUMERIC[(p,s)], где p - точность, s - масштаб. Они являются синонимами и
              взаимозаменяемы, но только NUMERIC может использоваться в комбинации со
              столбцами IDENTITY. Точность - это число значащих цифр, масштаб - число цифр
              после десятичной точки. </P>
            <P align=justify>Пример: NUMERIC(7,2).</P>
            <P align=justify>Если опущен масштаб, то он полагается равным нулю, а если
              опущена точность, то ее значение по умолчанию определяется в реализации.</P>
            
            <P align=left><I><U><FONT size=+1>Денежные типы данных</FONT></U></I></P>
            <TABLE width=469 class="data-table">
              <thead>
                <TR>
                  <th vAlign=top width="30%">
                    <P align=justify>Характеристика </P></th>
                  <th vAlign=top width="42%">
                    <P align=justify>MONEY </P></th>
                  <th vAlign=top width="28%">
                    <P align=justify>SMALLMONEY </P></th>
                </TR>
              </thead>
              <TBODY>
              <TR>
                <TD vAlign=top width="30%">
                  <P align=justify>Диапазон </P></TD>
                <TD vAlign=top width="42%">
                  <P align=justify>922337203685477.5808 </P></TD>
                <TD vAlign=top width="28%">
                  <P align=justify>214748.3647 </P></TD>
              </TR>
              <TR>
                <TD vAlign=top width="30%">
                  <P align=justify>Размер памяти </P></TD>
                <TD vAlign=top width="42%">
                  <P align=justify>8 байтов </P></TD>
                <TD vAlign=top width="28%">
                  <P align=justify>4 байта </P></TD>
              </TR>
              </TBODY>
            </TABLE>
          </div>
        </div>
      </div>
      <!--Создание таблицы-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#create-table"
        >
          Создание таблицы
        </h3>
        <div id="create-table" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Оператор создания таблицы имеет следующий синтаксис:</P>

            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;оператор создания таблицы&gt;::= CREATE TABLE &lt;имя таблицы&gt; (&lt;элемент таблицы&gt;[{,&lt;элемент таблицы&gt;}...])

    &lt;элемент таблицы&gt;::=&lt;определение столбца&gt; | &lt;определение ограничения целостности&gt;
  </code>
            </pre>
            <P align=justify>Каждая таблица БД имеет простое и квалифицированное
              (уточненное) имена. В качестве квалификатора имени выступает “идентификатор
              полномочий”.</P>
            <P align=justify>Квалифицированное имя таблицы имеет вид: <I>&lt;идентификатор
              полномочий&gt;.&lt;простое имя&gt;</I></P>
          </div>
        </div>
      </div>
      <!--Определение столбца-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#column-definition"
        >
          Определение столбца
        </h3>
        <div id="column-definition" class="accordion-body collapse">
          <div class="accordion-inner">
            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;определение столбца&gt;::= &lt;имя столбца&gt;&lt;тип данных&gt;[&lt;раздел умолчания&gt;] [{&lt;ограничение целостности столбца&gt;}...]

    &lt;раздел умолчания&gt;::= DEFAULT {&lt;литерал&gt; | USER | NULL}

    &lt;ограничение целостности столбца&gt;::= NOT NULL[&lt;спецификация уникальности&gt;] |
    &lt;спецификация ссылок&gt; | CHECK (&lt;условие поиска&gt;)

  </code>
            </pre>

            <P align=justify>В разделе умолчания указывается значение, которое должно быть
              помещено в строку, заносимую в данную таблицу, если значение данного столбца
              явно не указано. Значение по умолчанию может быть: 1) литеральная константа,
              соответствующая типу столбца; 2) символьная строка, содержащая имя текущего
              пользователя (USER); 3) неопределенное значение (NULL).</P>
            <P align=justify>Если значение столбца по умолчанию не специфицировано, и в
              разделе ограничений целостности столбца указано NOT NULL (т.е. наличие
              неопределенных значений запрещено), то попытка занести в таблицу строку с
              неспецифицированным значением данного столбца приведет к ошибке. </P>
            <P align=justify>Если ограничение NOT NULL не указано, и раздел умолчаний
              отсутствует, то неявно порождается раздел умолчаний DEFAULT NULL.</P>
            <P align=justify>Ограничения целостности столбца в принципе сходны с
              ограничениями целостности таблицы и рассмотрены ниже.</P>
          </div>
        </div>
      </div>
      <!--Определение ограничений целостности таблицы-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#table-integrity-constraints"
        >
          Определение ограничений целостности таблицы
        </h3>
        <div id="table-integrity-constraints" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=left>Синтаксис для определения ограничений целостности таблицы
              представлен следующими правилами:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;определение ограничений целостности таблицы&gt;::= &lt;определение ограничения уникальности&gt; | &lt;определение ограничения по
    ссылкам&gt; | &lt;определение проверочного ограничения&gt;

    &lt;определение ограничения уникальности&gt;::=&lt;спецификация уникальности&gt;(&lt;список столбцов&gt;)

    &lt;спецификация уникальности&gt;::= UNIQUE | PRIMARY KEY

    &lt;список столбцов&gt;::= &lt;имя столбца&gt;[{,&lt;имя столбца&gt;}..]

    &lt;определение ограничения по ссылкам&gt;::= FOREIGN KEY (&lt;ссылающиеся столбцы&gt;)&lt;спецификация ссылок&gt;

    &lt;спецификация ссылок&gt;::== REFERENCES &lt;ссылаемая таблица и столбцы&gt;

    &lt;ссылаемая таблица и столбцы&gt;::=&lt;имя таблицы&gt;[(&lt;список столбцов&gt;)]

    &lt;определение проверочного ограничения&gt;::= CHECK (&lt;условие поиска&gt;)

  </code>
            </pre>
            <P align=justify>Действие ограничения уникальности состоит в том, что в таблице
              не допускается появление двух или более строк, значения столбцов уникальности
              которых совпадают. Среди ограничений уникальности таблицы не должно быть более
              одного определения первичного ключа (ограничения уникальности с ключевым словом
              PRIMARY KEY).</P>
            <P align=justify>Ограничения по ссылкам в данной работе не используются, и
              поэтому подробно не рассматриваются.</P>
            <P align=justify>Проверочное ограничение специфицирует условие, которому должен
              удовлетворять в отдельности каждая строка таблицы. Это условие не должно
              содержать подзапросов, спецификаций агрегатных функций, а также ссылок на
              внешние переменные или параметров. В него могут входить только имена столбцов
              данной таблицы и литеральные константы.</P>
            <P align=justify>Примеры создания таблиц с ограничениями:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      CREATE TABLE employee
        (emp_id INTEGER CONSRAINT p1 PRIMARY KEY,
        fname CHAR(20) NOT NULL,
        minitial CHAR(1) NULL,
        lname VARCHAR(30) NOT NULL,
          job_id SMALLINT NOT NULL DEFAULT 1
          REFERENCES jobs(job_id)

      CREATE TABLE inventory
        (code CHAR(4) NOT NULL
          CONSTRAINT c1 CHECK(code LIKE"[0-9][0-9][0-9][0-9]"),
        high INT NOT NULL CHECK (high>0),
        low INT NOT NULL CHECK (low>0),
        CONSTRAIN c4 CHECK (hign>=low AND high-low<1000)
  </code>
            </pre>
          </div>
        </div>
      </div>
      <!--Изменение таблиц-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#change-table"
        >
          Изменение таблиц
        </h3>
        <div id="change-table" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Для изменения таблицы, а именно: для включения новых столбцов и
              ограничений, а также удаления ограничений, используется оператор ALTER TABLE,
              имеющий следующий синтаксис:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      &lt;оператор изменения таблицы&gt;::= ALTER TABLE &lt;имя таблицы&gt; {ADD &lt;элемент таблицы&gt;[{,&lt;элемент таблицы&gt;}...] | DROP
      CONSTRAINT &lt;имя ограничения&gt;[{,&lt;имя ограничения&gt;}...]}
  </code>
            </pre>
            <P align=justify>Пример включения нового столбца в таблицу:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
     ALTER TABLE names2 ADD middle_name VARCHAR(20) NULL, fax VARCHAR(15) NULL
  </code>
            </pre>
          </div>
        </div>
      </div>
      <!--Создание представлений-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#creating-views"
        >
          Создание представлений
        </h3>
        <div id="creating-views" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Механизм представлений является мощным средством языка SQL,
              позволяющим скрыть реальную структуру БД от некоторых пользователей за счет
              определения представления БД. Представление реально является некоторым хранимым
              в БД запросом с именованными столбцами, а для пользователя ничем не отличается
              от базовой таблицы БД. Представляемая таблица является виртуальной. Обычно
              вычисление представляемой таблицы производится каждый раз при использовании
              представления.</P>
            <P align=justify>Оператор определения представления имеет следующий
              синтаксис:</P>            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;оператор создания представления&gt;::= CREATE VIEW &lt;имя таблицы&gt;[(список столбцов)]
    AS &lt;спецификация запроса&gt; [WITH CHECK OPTION]

    &lt;спецификация запроса&gt;::= SELECT [ALL | DISTINCT] &lt;список выборки&gt;&lt;табличное выражение&gt;

    &lt;список столбцов&gt;::=&lt;имя столбца&gt;[{,&lt;имя столбца&gt;}...]
  </code>
            </pre>
            <P align=justify>Требование<I> </I>WITH CHECK OPTION<I> </I>имеет смысл только в
              случае определения изменяемой представляемой таблицы, которая определяется
              спецификацией запроса, содержащей раздел WHERE. При наличии этого требования не
              допускаются изменения представляемой таблицы, приводящие к появлению в базовых
              таблицах строк, не видимых в представляемой таблице.</P>
            <P align=justify>Примеры создания представлений:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      CREATE VIEW ta_limited AS
          SELECT au_id, title_id, au_ord FROM titleauthor

      CREATE VIEW cal_publishers AS
          SELECT * FROM publishers WHERE state="CA"
  </code>
      </pre>
          </div>
        </div>
      </div>
      <!--Операторы, связанные с курсором-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#operators-cursor"
        >
          Операторы, связанные с курсором
        </h3>
        <div id="operators-cursor" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Курсор - это механизм языка SQL, предназначенный для того,
              чтобы позволить прикладной программе последовательно, строка за строкой,
              просмотреть результат связанного с курсором запроса. Курсор можно представить
              как “буфер” с указателем на текущую строку. Ниже приводится синтаксис
              операторов, связанных с курсором и их краткая характеристика.</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      &lt;оператор объявления курсора&gt;::= DECLARE &lt;имя курсора&gt; [SCROLL] CURSOR FOR &lt;спецификация курсора&gt;

      &lt;спецификация курсора&gt;::= SELECT [ALL | DISTINCT] &lt;список выборки&gt;
      &lt;табличное выражение&gt;[ORDER BY &lt;спецификация сортировки&gt;]
  </code>
            </pre>

            <P align=justify>Этот оператор не является выполняемым, он только связывает имя
              курсора со спецификацией курсора. Если задан описатель SCROLL, то курсор
              является “скроллируемым”, то есть допускает прокрутку результирующей таблицы как
              вниз, так и вверх на любое число строк.</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      &lt;оператор открытия курсора&gt;::= OPEN &lt;имя курсора&gt;
  </code>
            </pre>

            <P align=justify>Оператор открытия курсора должен быть первым в серии
              выполняемых операторов, связанных с данным курсором. Можно считать, что во время
              выполнения оператора открытия курсора производится построение временной таблицы,
              содержащей результат запроса, который связан с этим курсором.</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      &lt;оператор чтения&gt;::= FETCH &lt;имя курсора&gt; INTO &lt;список спецификаций целей&gt;

      &lt;список спецификаций целей&gt;::= &lt;спецификация цели&gt;[{,&lt;спецификация цели&gt;}..]
  </code>
            </pre>

            <P align=justify>Данный оператор устанавливает курсор на следующую строку
              таблицы и выбирает значения из этой строки. </P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      &lt;оператор позиционного удаления&gt;::= DELETE FROM &lt;имя таблицы&gt; WHERE CURRENT OF &lt;имя курсора&gt;
  </code>
            </pre>

            <P align=justify>Данный оператор удаляет строку таблицы. Изменяемая таблица,
              указанная в разделе FROM оператора DELETE, должна быть таблицей, указанной в
              самом внешнем разделе FROM спецификации курсора.</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    &lt;оператор позиционной модификации&gt;::= UPDATE &lt;имя таблицы&gt; SET &lt;предложение установки&gt; [{,&lt;предложение
    установки&gt;}...] WHERE CURRENT OF &lt;имя курсора&gt;

    &lt;предложение установки&gt;::= &lt;имя столбца&gt; = {&lt;арифметическое выражение&gt; | NULL}
  </code>
            </pre>

            <P align=justify>Данный оператор изменяет значение полей строки таблицы,
              определенной курсором, в соответствии с предложениями установки.</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      &lt;оператор закрытия курсора&gt;::= CLOSE &lt;имя курсора&gt;
  </code>
            </pre>
            <P align=justify>
              <ins>Примеры работы с курсором:</ins>
            </P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      DECLARE mycursor SCROLL CURSOR FOR
          SELECT au_lname FROM authors

      OPEN mycursor

      FETCH FIRST FROM mycursor /* первая строка */

      FETCH ABSOLUTE 10 FROM mycursor

      FETCH NEXT FROM mycursor /* следующая строка */

      FETCH RELATIVE 2 FROM mycursor

      FETCH PRIOR FROM mycursor /* предыдущая строка */

      FETCH LAST FROM mycursor /* последняя строка */

      CLOSE mycursor
  </code>
            </pre>
          </div>
        </div>
      </div>

      <!--Одиночные операторы манипулирования данными-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#operators-data-manipulation"
        >
          Одиночные операторы манипулирования данными
        </h3>
        <div id="operators-data-manipulation" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Каждый из операторов этой группы является абсолютно независимым
              от другого оператора.</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      &lt;оператор выборки&gt;::= SELECT [ALL | DISTINCT] &lt;список выборки&gt;
      [INTO &lt;список спецификаций целей&gt;]&lt;табличное выражение&gt;
  </code>
            </pre>
            <P align=justify><I></I></P>

            <P align=justify>Результатом выполнения оператора выборки является таблица,
              состоящая не более чем из одной строки. После выполнения оператора цели содержат
              соответствующие поля результирующей строки.</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      &lt;оператор поискового удаления&gt;::= DELETE FROM &lt;имя таблицы&gt; [WHERE &lt;условие поиска&gt;]
  </code>
            </pre>
            <P align=justify><I></I></P>

            <P align=justify>При выполнении оператора последовательно просматриваются все
              строки таблицы, и те строки, для которых результатом вычисления условия поиска
              является “истина”, удаляются из таблицы. При отсутствии раздела WHERE удаляются
              все строки таблицы.</P>
            <P align=justify>Примеры:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      DELETE authors
      DELETE titles WHERE type= "business"
      &lt;оператор поисковой модификации&gt;::= UPDATE &lt;имя таблицы&gt;
      SET &lt;предложение установки &gt;[{,&lt;предложение установки&gt;}…] [WHERE &lt;условие поиска&gt;]
  </code>
            </pre>

            <P align=justify>При выполнении оператора просматриваются все строки таблицы, и
              каждая строка, для которой результатом вычисления условия поиска является
              “истина”, изменяется в соответствии с разделом SET. </P>
            <P align=justify>Пример:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      UPDATE publishers SET pub_name= "Joe’s Press" WHERE pub_id="1234"
      &lt;оператор включения&gt;::= INSERT INTO &lt;имя таблицы&gt;[(&lt;список столбцов&gt;)]
      {VALUES (&lt;список значений &gt;) | &lt;подзапрос&gt;}
  </code>
            </pre>

            <P align=justify>Оператор включения добавляет строку в таблицу. При это строка
              формируется или из списка значений раздела VALUES, или вычисляется с помощью
              подзапроса. Список столбцов определяет те столбцы, для которых явно будет
              указано их значение. Причем i-му столбцу в списке столбцов соответствует i-ое
              значение из списка значений или i-я строка результата подзапроса. Если список
              столбцов опущен, то для каждого столбца таблицы должно быть точно указаны (или
              вычислены) значения, в порядке, в котором они были определены.</P>
            <P align=justify>При вставке символьных данных или поиске значения в конструкции
              WHERE значение необходимо передавать в одиночных или двойных кавычках. Для
              вставки в столбец двоичных данных их нужно указывать без кавычек, начиная с 0х и
              задавая два шестнадцатеричных символа для каждого байта данных.</P>
            <P align=justify>Примеры:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      INSERT INTO publishers (pub_id, pub_name, cite, state) VALUES (‘1234’, ‘Stendahl Publishing’, ‘Paris’, ‘France’)

      INSERT INTO binary_example(id, bin_column) VALUES(19, 0xa134e2ff)
  </code>
            </pre>
          </div>
        </div>
      </div>
      <!--Создание индекса-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#create-index"
        >
          Создание индекса
        </h3>
        <div id="create-index" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Индекс представляет собой объект, ускоряюший выполнение
              запросов. Синтаксис оператора создания индекса имеет вид:</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      &lt;оператор создания индекса&gt;::= CREATE [UNIQUE] INDEX &lt;имя индекса&gt;
      ON &lt;имя таблицы&gt; (&lt;имя столбца&gt; [ASC | DESC] [{,&lt;имя столбца&gt;[ASC | DESC]}..])
  </code>
            </pre>
            <P align=justify>Описатель уникальности UNIQUE указывает, что никаким двум
              строкам в индексируемой базовой таблице не позволяется принимать одно и тоже
              значение для индексируемого столбца (или комбинации столбцов) в одно и то же
              время. Описатели ASC и DESC определяют, что столбец должен быть отсортирован в
              возрастающем или убывающем порядке в пределах индекса. В Transact-SQL описатели
              ASC и DESC не используются.</P>
          </div>
        </div>
      </div>
      <!--Удаление объектов базы данных-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#remove-object-db"
        >
          Удаление объектов базы данных
        </h3>
        <div id="remove-object-db" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Для удаления объектов базы данных используются соответствующие
              операторы, синтаксис которых представлен ниже.</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      &lt;оператор удаления таблицы&gt;::= DROP TABLE &lt;имятаблицы&gt;

      &lt;оператор удаления представления&gt;::= DROP VIEW &lt;имя представления&gt;

      &lt;оператор удаления представления&gt;::= DROP INDEX &lt;имя индекса&gt;
  </code>
            </pre>
          </div>
        </div>
      </div>
      <!--Получение справочной информации об объектах базы данных-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#get-about-info"
        >
          Получение справочной информации об объектах базы данных
        </h3>
        <div id="get-about-info" class="accordion-body collapse">
          <div class="accordion-inner">
            <P align=justify>Информацию об объектах текущей базы данных можно получить,
              запустив хранимую процедуру SP_HELP, выполнив оператор </P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      SP_HELP &lt;имя объекта&gt;
  </code>
            </pre>
            <P align=justify>Для объекта-таблицы отображаются: имя собственника таблицы;
              дата и время ее создания; имена столбцов таблицы и их типы данных; имена,
              описания и ключи индексов, связанных с таблицей; типы, имена и описания
              ограничений столбцов и таблицы в целом. Без входных параметров эта процедура
              возвращает список всех объектов, их собственников и типов объектов.</P>
            <P align=justify>Для получения информации только об ограничениях таблицы можно
              воспользоваться хранимой процедурой SP_HELPCONSTRAINT, выполнив оператор</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      SP_HELPCONSTRAINT &lt;имя таблицы&gt;
  </code>
            </pre>
            <P align=justify>Для получения информации только об индексах таблицы можно
              воспользоваться хранимой процедурой SP_HELPINDEX, выполнив оператор</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      SP_HELPINDEX &lt;имя таблицы&gt;
  </code>
            </pre>
            <P align=justify>Для того, чтобы получить список и описания объектов класса X,
              определенных в базе данных, можно выполнить оператор</P>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      SELECT * FROM sysobjects WHERE type= ‘X’
  </code>
            </pre>
            <P align=justify>Возможные значения параметра X: U - таблица, V - представление,
              С - проверочное ограничение, F - ограничение по ссылкам, K - ограничение
              уникальности, D - раздел умолчаний.</P>
          </div>
        </div>
      </div>
      <!--Варианты заданий-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#job-options"
        >
          Варианты заданий
        </h3>
        <div id="job-options" class="accordion-body collapse">
          <div class="accordion-inner">
            <OL>
              <LI><U><FONT size=+1>Схема таблицы СТУДЕНТ:</FONT></U></LI>
            </OL>
            <UL>
              <LI>идентификатор зачетки
              <LI>фамилия и инициалы студента
              <LI>специальность
              <LI>группа
              <LI>дата рождения
              <LI>наличие стипендии (имеется/не имеется)
              <LI>адрес проживания
              <LI>средний балл зачетки</LI>
            </UL>
            <div class="indent-left">
                <P align=justify><U>Ограничение уникальности:</U> идентификатор зачетки.</P>
                <P align=justify><U>Проверочные ограничения: </U> <br>
                  а) Код группы должен иметь следующую структуру: &lt;цифра&gt;&lt;цифра&gt;&lt;буква&gt;&lt;буква&gt;&lt;цифра&gt;;
                  <br>
                  б) Cредний балл зачетки должен быть в интервале [2,5].</P>
                <P align=justify><U>Спецификация представления:</U> представляемая таблица
                  содержит идентификатор зачетки, фамилию и инициалы студента, а также средний
                  балл зачетки для студентов, получающих стипендию.</P>
                <P align=justify><U>Спецификация курсора:</U> результирующая таблица
                  включает фамилию и инициалы студента, группу и адрес проживания для
                  студентов, имеющих средний балл зачетки более 4.5.</P>
            </div>
            <OL start=2>
              <LI><U><FONT size=+1>Схема таблицы ЭКЗАМЕН:</FONT></U></LI>
            </OL>
            <UL>
              <LI>название предмета
              <LI>фамилия и инициалы студента
              <LI>фамилия и инициалы преподавателя
              <LI>должность преподавателя
              <LI>дата сдачи экзамена
              <LI>номер аудитории
              <LI>оценка
              <LI>сложность предмета</LI>
            </UL>
            <div  class="indent-left">
              <P align=justify><U>Ограничение уникальности:</U> название предмета, фамилия
                и инициалы студента.</P>
              <P align=justify><U>Проверочные ограничения:</U> <br>
                а) должность преподавателя
                должна быть одной из следующего списка: ассистент, старший преподаватель,
                доцент, профессор; <br>
                б) сложность предмета должна быть в интервале [0,1].</P>
              <P align=justify><U>Спецификация представления:</U> представляемая таблица
                содержит название предмета, фамилию и инициалы студента, а также
                экзаменационную оценку для тех экзаменов, которые принимают профессора.</P>
              <P align=justify><U>Спецификация курсора:</U> результирующая таблица
                включает все сведения об экзаменах, сданных на оценку
                “отлично”.</P>
            </div>
            <OL start=3>
              <LI><U><FONT size=+1>Схема таблицы ВОЕННОСЛУЖАЩИЕ:</FONT></U></LI>
            </OL>
            <UL>
              <LI>номер военного билета
              <LI>фамилия и инициалы
              <LI>дата рождения
              <LI>род войск
              <LI>воинское звание
              <LI>оклад
              <LI>рост
              <LI>вес
              <LI>номер противогаза
              <LI>наличие водительских прав (имеются/не имеются)</LI>
            </UL>
            <div  class="indent-left">
                <P align=justify><U>Ограничение уникальности:</U> номер военного билета.</P>
                <P align=justify><U>Проверочные ограничения:</U> а) номер военного билета
                  должен состоять из шести цифр; б) номер противогаза должен быть цифрой 1,2
                  или 3.</P>
                <P align=justify><U>Спецификация представления:</U> представляемая таблица
                  содержит номер военного билета, фамилию и инициалы, род войск военнослужащих
                  ростом более 180 см.</P>
                <P align=justify><U>Спецификация курсора:</U> результирующая содержит
                  фамилию и инициалы, воинское звание, номер противогаза военнослужащих,
                  имеющих водительские права.</P>
            </div>
            <OL start=4>
              <LI><U><FONT size=+1>Схема таблицы КОМПЬЮТЕР:</FONT></U></LI>
            </OL>
            <UL>
              <LI>марка компьютера
              <LI>страна сборки
              <LI>процессор
              <LI>объем оперативной памяти
              <LI>объем внешней памяти
              <LI>быстродействие
              <LI>наличие мыши (имеется/не имеется)
              <LI>марка монитора
              <LI>цена
              <LI>дата выпуска</LI>
            </UL>
            <div class="indent-left">
                <P align=justify><U>Ограничение уникальности:</U> марка компьютера, страна
                  сборки.</P>
                <P align=justify><U>Проверочные ограничения:</U> а) объем оперативной памяти
                  должен быть в интервале [2,128] Мбайт; б) Дата выпуска должна быть не больше
                  текущей даты.</P>
                <P align=justify><U>Спецификация представления:</U> представляемая таблица
                  содержит марку компьютера, страну сборки и цену для компьютеров, имеющих
                  объем оперативной памяти более 8 Мбайт.</P>
                <P align=justify><U>Спецификация курсора:</U> результирующая таблица
                  совпадает с базовой.</P>
            </div>
            <OL start=5>
              <LI><U><FONT size=+1>Схема таблицы УЧЕБНЫЙ ПЛАН:</FONT></U></LI>
            </OL>
            <UL>
              <LI>код специальности
              <LI>название дисциплины
              <LI>семестр
              <LI>дата начала семестра
              <LI>общее количество часов
              <LI>наличие курсового проекта (имеется/не имеется)
              <LI>формы отчетности (экзамены, зачеты и т.д.)</LI>
            </UL>
            <div class="indent-left">
                <P align=justify><U>Ограничение уникальности:</U> код специальности,
                  название дисциплины, семестр.</P>
                <P align=justify><U>Проверочные ограничения:</U><br> а) код специальности должен
                  иметь следующую структуру:
                  &lt;цифра&gt;&lt;цифра&gt;.&lt;цифра&gt;&lt;цифра&gt;; <br> б) семестр должен
                  быть или осенний или весенний.</P>
                <P align=justify><U>Спецификация представления:</U> представляемая таблица
                  содержит код специальности, семестр и название дисциплин, для которых
                  предусмотрен курсовой проект.</P>
                <P align=justify><U>Спецификация курсора:</U> результирующая таблица
                  содержит все сведения о дисциплинах весеннего
                  семестра.</P>
            </div>
            <OL start=6>
              <LI><U><FONT size=+1>Схема таблицы ПОСТАВКИ ТОВАРОВ:</FONT></U></LI>
            </OL>
            <UL>
              <LI>название фирмы-поставщика
              <LI>название фирмы-потребителя
              <LI>товарный кредит (да/нет)
              <LI>название товара
              <LI>количество единиц товара
              <LI>вес единицы товара
              <LI>цена единицы товара
              <LI>платежные реквизиты (адрес и номер расчетного счета)
              <LI>дата отгрузки</LI>
            </UL>
            <div class="indent-left">
                <P align=justify><U>Ограничение уникальности:</U> название фирмы-поставщика,
                  название фирмы-потребителя.</P>
                <P align=justify><U>Проверочные ограничения:</U><br>а) поставляемыми товарами
                  являются холодильники, пылесосы и утюги; <br> б) количество поставляемых единиц
                  товара не должно превышать 100 штук.</P>
                <P align=justify><U>Спецификация представления:</U> представляемая таблица
                  содержит сведения о товарах.</P>
                <P align=justify><U>Спецификация курсора:</U> результирующая таблица
                  содержит название фирмы-поставщика, название фирмы-потребителя и название
                  товара для поставок, в которых используется товарный
                  кредит.</P>
            </div>
            <OL start=7>
              <LI><U><FONT size=+1>Схема таблицы АВТОТРАНСПОРТ:</FONT></U></LI>
            </OL>
            <UL>
              <LI>государственный номер
              <LI>тип (автобус, самосвал, тягач, джип)
              <LI>марка
              <LI>год изготовления
              <LI>грузоподъемность или вместимость
              <LI>расход горючего на 100 км
              <LI>пробег к текущему техосмотру
              <LI>дата проведения последнего техосмотра
              <LI>успешность техосмотра (положительная/отрицательная)</LI>
            </UL>
            <div  class="indent-left">
                <P align=justify><U>Ограничение уникальности:</U> государственный номер.</P>
                <P align=justify><U>Проверочные ограничения:</U> <br> а) государственный номер
                  имеет следующую структуру:
                  &lt;буква&gt;&lt;цифра&gt;&lt;цифра&gt;&lt;цифра&gt;&lt;буква&gt;&lt;буква&gt;; <br>
                  б) автотранспорт может быть следующих типов: автобус, самосвал, тягач,
                  джип.</P>
                <P align=justify><U>Спецификация представления:</U> представляемая таблица
                  содержит государственный номер, тип и марку автотранспорта, успешно
                  прошедшего техосмотр.</P>
                <P align=justify><U>Спецификация курсора:</U> результирующая таблица
                  содержит тип автотранспорта, грузоподъемность (вместимость) и дату
                  проведения последнего техосмотра для автотранспорта, выпущенного за
                  последние пять лет.</P>
            </div>
            <OL start=8>
              <LI><U><FONT size=+1>Схема таблицы ФАКУЛЬТЕТ:</FONT></U></LI>
            </OL>
            <UL>
              <LI>название факультета
              <LI>фамилия и инициалы декана
              <LI>телефон деканата
              <LI>дата основания факультета
              <LI>число выпускающих кафедр
              <LI>число обучаемых студентов
              <LI>наличие иностранных студентов (имеются/не имеются)
              <LI>удельный вес преподавателей с учеными степенями</LI>
            </UL>
            <div class="indent-left">
                <P align=justify><U>Ограничение уникальности:</U> название факультета.</P>
                <P align=justify><U>Проверочные ограничения:</U><br>а) телефон деканата должен
                  иметь следующую структуру:
                  63-&lt;цифра&gt;&lt;цифра&gt;-&lt;цифра&gt;&lt;цифра&gt;;<br> б) удельный вес
                  преподавателей с учеными степенями должен быть в интервале [0,1].</P>
                <P align=justify><U>Спецификация представления:</U> представляемая таблица
                  содержит название факультета, фамилию и инициалы деканата, а также число
                  выпускающих кафедр для факультетов, на которых учатся иностранные
                  студенты.</P>
                <P align=justify><U>Спецификация курсора:</U> результирующая таблица
                  содержит фамилию и инициалы декана, телефон и дату основания
                  деканата.</P>
            </div>
            <OL start=9>
              <LI><U><FONT size=+1>Схема таблицы УСПЕВАЕМОСТЬ:</FONT></U></LI>
            </OL>
            <UL>
              <LI>факультет
              <LI>специальность
              <LI>дисциплина
              <LI>общее количество студентов
              <LI>количество сдававших студентов
              <LI>удельные веса отличных, хороших, удовлетворительных и неудовлетворительных
                оценок
              <LI>дата начала экзаменационной сессии</LI>
            </UL>
            <div class="indent-left">
                <P align=justify><U>Ограничение уникальности:</U> факультет, специальность,
                  дисциплина.</P>
                <P align=justify><U>Проверочные ограничения:</U> <br> а) количество сдававших
                  студентов не должно быть больше количества студентов; <br>б) сумма удельных
                  весов отличных, хороших, удовлетворительных и неудовлетворительных оценок
                  должна быть равной 1.</P>
                <P align=justify><U>Спецификация представления:</U> представляемая таблица
                  содержит названия специальности и дисциплины, а также количество сдававших
                  студентов для факультета вычислительной техники.</P>
                <P align=justify><U>Спецификация курсора:</U> результирующая таблица
                  содержит все сведения об успеваемости на специальности “Вычислительные
                  машины, комплексы, системы и сети”.</P>
            </div>
            <OL start=10>
              <LI><U><FONT size=+1>Схема таблицы ЖИВОТНОЕ:</FONT></U></LI>
            </OL>
            <UL>
              <LI>название животного
              <LI>класс животного
              <LI>максимальный вес животного
              <LI>минимальный вес животного
              <LI>средний вес животного
              <LI>окраска
              <LI>место обитания
              <LI>дата занесения в Красну книгу
              <LI>продолжительность жизни
              <LI>летательные способности (летает/не летает)</LI>
            </UL>
            <div class="indent-left">
                <P align=justify><U>Ограничение уникальности:</U> название животного.</P>
                <P align=justify><U>Проверочные ограничения:</U><br> а) средний вес животного
                  должен быть больше минимального веса и меньше максимального веса;<br> б) дата
                  занесения в Красную Книгу не должна быть больше текущей даты.</P>
                <P align=justify><U>Спецификация представления:</U> представляемая таблица
                  содержит сведения о весе животных.</P>
                <P align=justify><U>Спецификация курсора:</U> результирующая таблица
                  содержит название, класс и средний вес животных, способных
                  летать.</P>
            </div>
            <OL start=11>
              <LI><U><FONT size=+1>Схема таблицы ФИРМА:</FONT></U></LI>
            </OL>
            <UL>
              <LI>название фирмы
              <LI>организационно-правовая форма (ООО, ОАО, ТОО и т.д.)
              <LI>юридический адрес
              <LI>дата учреждения
              <LI>количество работников
              <LI>число работников, имеющих водительские права
              <LI>средний оклад работников
              <LI>средний возраст работников
              <LI>направления деятельности
              <LI>задолженность по налогам (имеется/не имеется)</LI>
            </UL>
            <div class="indent-left">
                <P align=justify><U>Ограничение уникальности:</U> название фирмы.</P>
                <P align=justify><U>Проверочные ограничения:</U> <br>а) число работников,
                  имеющих водительские права не должно превышать общее количество работников;<br>
                  б) средний возраст работников не должен превышать 35 лет.</P>
                <P align=justify><U>Спецификация представления:</U> представляемая таблица
                  включает название фирмы и соответствующие обобщенные сведения о работниках
                  этой фирмы.</P>
                <P align=justify><U>Спецификация курсора:</U> результирующая таблица
                  содержит название фирмы, юридический адрес и количество работников, причем
                  удельный вес работников фирмы, имеющих водительские права, превышает 60%.
                </P>
            </div>
            <OL start=12>
              <LI><U><FONT size=+1>Схема таблицы ТЕЛЕВИЗОР:</FONT></U></LI>
            </OL>
            <UL>
              <LI>марка телевизора
              <LI>страна сборки
              <LI>тип кинескопа
              <LI>размер по диагонали
              <LI>системы цветности
              <LI>число каналов
              <LI>наличие телетекста (имеется/не имеется)
              <LI>звук (моно/.стерео)
              <LI>выходная мощность
              <LI>вес
              <LI>потребляемая мощность
              <LI>дата продажи</LI>
            </UL>
            <div class="indent-left">
                <P align=justify><U>Ограничение уникальности:</U> марка телевизора, страна
                  сборки.</P>
                <P align=justify><U>Проверочные ограничения: </U> <br>а) система цветности может
                  быть следующих типов: PAL/SECAM, B/G, D/K, H, I, M, NTSC, VIT);<br> б) число
                  каналов должно быть не меньше 40.</P>
                <P align=justify><U>Спецификация представления:</U> представляемая таблица
                  содержит марку телевизора, страну сборки и потребляемую мощность для
                  телевизоров, имеющих телетекст.</P>
                <P align=justify><U>Спецификация курсора:</U> результирующая таблица
                  совпадает с базовой.</P>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="lab-3-content" class="content-lab" >
      <h3 class="lab-title">Лабораторная работа №3</h3>
      <h3 class="lab-title">Соединение с базой данных в ODBC</h3>
      <p class="lab-subtitle"><b>Цель работы:</b> изучить функции ODBC для соединения с базой данных, а также функции для получения информации о
        драйвере и источнике данных, приобрести навыки использования данных функций при разработке клиентских приложений баз
        данных.</p>

      <h3 class="title-p">Порядок выполнения работы</h3>
      <ul>
        <li>Ознакомиться с концепцией ODBC.</li>
        <li>Изучить программный интерфейс функций SQLAllocHandle, SQLFreeHandle, SQLConnect, SQLDisconnect, SQLGetInfo и
          SQLGetFunctions.
        </li>
        <li>Написать на языке программирования высокого уровня C/C++ программу, которая устанавливает соединение с источником
          данных, получает определенную вариантом задания информацию о драйвере и источнике данных, разъединяет соединение с
          источником данных.
        </li>
        <li>Запустить ODBC-администратор и с его помощью выбрать ODBC-драйвер для используемого в программе источника
          данных.
        </li>
        <li>Выполнить программу, разработанную в п.3.</li>
        <li>Оформить отчет о проделанной работе.</li>
      </ul>

      <h3 class="title-p">Содержание отчета</h3>
      <ul>
        <li>Задание;</li>
        <li>Краткое описание используемых функций ODBC;</li>
        <li>Краткое описание программы;</li>
        <li>Листинг программы;</li>
        <li>Результаты выполнения программы;</li>
      </ul>
      <p>Для последующих лабораторных работ содержание отчета будет иметь такую же структуру.</p>
      <h3 class="title-p">Методические указания</h3>
      <p>Обобщенный алгоритм использования ODBC в прикладных программах представлен ниже (в скобках указаны основные
        используемые функции).</p>
      <p class="text-undeline">Фаза инициализации</p>
      <ul>
        <li>Назначение идентификатора среды (SQLAllocHandle с аргументом SQL_HANDLE_ENV)</li>
        <li>Назначение идентификатора соединения (SQLAllocHandle с аргументом SQL_HANDLE_DBC)</li>
        <li>Соединение с сервером (SQLConnect)</li>
        <li>Назначение идентификатора соединения (SQLAllocHandle с аргументом SQL_HANDLE_STMT)</li>
      </ul>
      <p class="text-undeline">Фаза обработки SQL операторов</p>
      <ul>
        <li>Выполнение оператора (SQLGetFunctions, SQLGetInfo)</li>
      </ul>
      <p class="text-undeline">Фаза завершения</p>
      <ul>
        <li>Освобождение идентификатора оператора (SQLFreeHandle с аргуументом SQL_HANDLE_STMT)</li>
        <li>Разрыв соединения с сервером (SQLDisconnect)</li>
        <li>Освобождение идентификатора соединения (SQLFreeHandle с аргуументом SQL_HANDLE_DBC)</li>
        <li>Освобождение идентификатора окружения (SQLFreeHandle с аргуументом SQL_HANDLE_ENV)</li>
      </ul>
      Для возможности работы с функциями ODBC в программу на языке С++ необходимо включить заголовочные файлы windows.h и
      sqlext.h
      <br>

      <pre class='code code-sql'><label>C++</label>
  <code>
      <span style="color: #339900;">#include &lt;windows.h&gt;</span>
      <span style="color: #339900;">#include &lt;sqlext.h&gt;</span>
  </code>
      </pre>

      <!--Основные сведения-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#main-info"
        >
          Основные сведения
        </h3>
        <div id="main-info" class="accordion-body collapse">
          <div class="accordion-inner">
            <p> ODBC (англ. Open Database Connectivity) — это программный интерфейс (API) доступа к базам данных, разработанный
              фирмой Microsoft, в сотрудничестве с Simba Technologies на основе спецификаций Call Level Interface (CLI).
              Впоследствии CLI был стандартизован ISO.</p>

            <p>ODBC позволяет устранить необходимость в независимых поставщиках программного обеспечения и необходимость
              разработчикам изучать несколько интерфейсов для работы с разными СУБД. ODBC предоставляет универсальный интерфейс
              доступа к данным. С ODBC, разработчики приложений могут разрешить приложению одновременно просматривать и изменять
              данные из нескольких разных баз данных.</p>
          </div>
        </div>
      </div>
      <!--Описание функций-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#description-functions"
        >
          Описание функций
        </h3>
        <div id="description-functions" class="accordion-body collapse">
          <div class="accordion-inner">
            <p><strong><font size="4px">
              <ins><a href="https://msdn.microsoft.com/en-us/library/ms712455(v=vs.85).aspx">SQLAllocHandle</a></ins>
            </font></strong> - Получает идентификатор (дескриптор) среды, соединения или оператора, или дескриптор приложения.
            </p>

            <p>
              <ins><strong>Синтаксис</strong></ins>
            </p>
            <pre class="cpp" style="font-family:monospace;"></pre>
            <pre class='code code-sql'><label>SQL</label>
  <code>
    SQLRETURN SQLAllocHandle<span >&#40;</span>
        SQLSMALLINT   HandleType,
        SQLHANDLE     InputHandle,
        SQLHANDLE  *  OutputHandlePtr &#41; ;
  </code>
            </pre>

            <div><strong>Аргументы:</strong>
              <br>
              <div class="indent-left">
                <ins>HandleType</ins>
                - (входной параметр) тип идентификатора используемый функцией. Может иметь следующие значения:
                <ul>
                  <li>SQL_HANDLE_DBC - распределяет память для идентификатора соединения в рамках среды.</li>
                  <li>SQL_HANDLE_DBC_INFO_TOKEN</li>
                  <li>SQL_HANDLE_DESC</li>
                  <li>SQL_HANDLE_ENV - распределяет память для идентификатора среды и инициализирует интерфейс ODBC.</li>
                  <li>SQL_HANDLE_STMT - распределяет память для идентификатора оператора в рамках определенного соединения.</li>
                </ul>
                <p>Аргументы SQL_HANDLE_DBC_INFO_TOKEN и SQL_HANDLE_DESC используются только диспетчером драйверов и драйверами.</p>
                <p>
                  <ins>InputHandle</ins>
                  - (входной параметр) входной идентификатор в рамках которого происходит инициализация нового идентификатора. Если
                  HandleType - SQL_HANDLE_ENV новый идентификатор - SQL_NULL_HANDLE. Если HandleType - SQL_HANDLE_DBC новый
                  идентификатор будет указателем на окружающую среду. Если HandleType - SQL_HANDLE_STMT новый идентификатор будет
                  указателем на соединение.
                  <br>
                  <ins>OutputHandlePtr</ins>
                  - (выходной параметр) указатель на память в которую будет записан выделенный идентификатор.
                </p>
              </div>
            </div>

            <p><strong>Возвращаемые параметры</strong></p>
            <ul>
              <li>SQL_SUCCESS - функция выполнена успешно</li>
              <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
              <li>SQL_INVALID_HANDLE - Аргумент HandleType некоректен.</li>
              <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
            </ul>

            <p><strong><font size="4px">
              <ins>
                <a href="https://msdn.microsoft.com/en-us/library/ms710123(v=vs.85).aspx">
                  SQLFreeHandle
                </a>
              </ins>
            </font></strong> - Освобождает ресурсы, ассоциированные с указанным идентификатором (дескриптором) (среды, соединения,
              оператора, идентификатора).
            </p>

            <p>
              <ins><strong>Синтаксис</strong></ins>
            </p>

            <pre class='code code-sql'><label>SQL</label>
  <code>
      SQLRETURN SQLFreeHandle<span >&#40;</span>
      SQLSMALLINT   HandleType,
      SQLHANDLE     Handle<span >&#41;</span><span style="color: #008080;">;</span>
  </code>
            </pre>

            <div><strong>Аргументы:</strong>
              <br>
              <div class="indent-left">
                <ins>HandleType</ins>
                - (входной параметр) тип идентификатора используемый функцией. Может иметь те же значения, что и в функции
                SQLAllocHandle.
                <br>
                <ins>Handle</ins>
                - (входной параметр) Освобождаемый идентификатор.
              </div>
            </div>

            <p><strong><strong>Возвращаемые параметры</strong>:</strong></p>
            <ul>
                <li>SQL_SUCCESS - функция выполнена успешно</li>
                <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
                <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec. В этом
                  случаее идентификатор не освобождается и остаётся в силе.
                </li>
            </ul>

            <p><strong><font size="4px">
              <ins><a href="https://msdn.microsoft.com/en-us/library/ms711810(v=vs.85).aspx">SQLConnect</a></ins>
            </font></strong> - устанавливает соединение с драйвером и источником данных. Соединение использует
              идентификатор(дескриптор) для хранения всей информации о подключении к источнику данных, включая состояние,
              состояние транзакции, а также информацию об ошибке.
            </p>

            <p>
              <ins><strong>Синтаксис</strong></ins>
            </p>
            <pre class='code code-sql'><label>SQL</label>
  <code>
      SQLRETURN SQLConnect<span >&#40;</span>
          SQLHDBC        ConnectionHandle,
          SQLCHAR *      ServerName,
          SQLSMALLINT    NameLength1,
          SQLCHAR *      UserName,
          SQLSMALLINT    NameLength2,
          SQLCHAR *      Authentication,
          SQLSMALLINT    NameLength3<span >&#41;</span><span">;</span>
  </code>
            </pre>

            <div><strong>Аргументы:</strong>
              <br/>
              <div class="indent-left">
                <ins>ConnectionHandle</ins>
                  - (входной параметр) Идентификатор соединения.
                  <br>
                  <ins>ServerName</ins>
                  - (входной параметр) Имя источника данных. Данные могут быть размещены на том же компьютере, что и программа, или на
                  другом компьютере где-то в сети.
                  <br>
                  <ins>NameLength1</ins>
                  - (входной параметр) Длина * ServerName в символах.
                  <br>
                  <ins>UserName</ins>
                  - (входной параметр) Идентификатор пользователя.
                  <br>
                  <ins>NameLength2</ins>
                  - (входной параметр) Длина * UserName в символах.
                  <br>
                  <ins>Authentication</ins>
                  - (входной параметр) Строка аутентификации (как правило, пароль).
                  <br>
                  <ins>NameLength3</ins>
                  - (входной параметр) Длина * Authentication в символах.
              </div>
            </div>

            <p><strong>Возвращаемые параметры</strong></p>
            <ul>
              <li>SQL_SUCCESS - функция выполнена успешно</li>
              <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
              <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
              <li>SQL_INVALID_HANDLE - Аргумент ConnectionHandle некоректен.</li></ul>
            <br>
              <!--Пример кода с++-->
    <pre class='code code-sql'><label>C++</label>
      <code>

        <span style="color: #339900;">#include &lt;sqlext.h&gt;</span>
      &nbsp;
      <span style="color: #0000ff;">int</span> main&#40;</span>&#41;</span> <span
            style="color: #008000;">&#123;</span>
         SQLHENV henv<span style="color: #008080;">;</span>
         SQLHDBC hdbc<span style="color: #008080;">;</span>
         SQLHSTMT hstmt<span style="color: #008080;">;</span>
         SQLRETURN retcode<span style="color: #008080;">;</span>
      &nbsp;
         SQLCHAR <span style="color: #000040;">*</span> OutConnStr <span style="color: #000080;">=</span> <span
            style="color: #008000;">&#40;</span>SQLCHAR <span style="color: #000040;">*</span> &#41;</span><span
            style="color: #0000dd;">malloc</span>&#40;</span><span
            style="color: #0000dd;">255</span>&#41;</span><span style="color: #008080;">;</span>
         SQLSMALLINT <span style="color: #000040;">*</span> OutConnStrLen <span style="color: #000080;">=</span> <span
            style="color: #008000;">&#40;</span>SQLSMALLINT <span style="color: #000040;">*</span><span
            style="color: #008000;">&#41;</span><span style="color: #0000dd;">malloc</span><span
            style="color: #008000;">&#40;</span><span style="color: #0000dd;">255</span><span
            style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
      &nbsp;
         <span style="color: #666666;">// Выделение идентификатора среды</span>
         retcode <span style="color: #000080;">=</span> SQLAllocHandle&#40;</span>SQL_HANDLE_ENV, SQL_NULL_HANDLE, <span
            style="color: #000040;">&amp;</span>henv&#41;</span><span
            style="color: #008080;">;</span>
      &nbsp;
         <span style="color: #666666;">// Установите атрибут версии ODBC</span>
         <span style="color: #0000ff;">if</span> &#40;</span>retcode <span
            style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
            style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO&#41;</span> <span
            style="color: #008000;">&#123;</span>
            retcode <span style="color: #000080;">=</span> SQLSetEnvAttr&#40;</span>henv, SQL_ATTR_ODBC_VERSION, <span
            style="color: #008000;">&#40;</span><span style="color: #0000ff;">void</span><span
            style="color: #000040;">*</span>&#41;</span>SQL_OV_ODBC3, <span
            style="color: #0000dd;">0</span>&#41;</span><span style="color: #008080;">;</span>
      &nbsp;
            <span style="color: #666666;">// Выделение идентификатора соединения</span>
            <span style="color: #0000ff;">if</span> &#40;</span>retcode <span
            style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
            style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO&#41;</span> <span
            style="color: #008000;">&#123;</span>
               retcode <span style="color: #000080;">=</span> SQLAllocHandle&#40;</span>SQL_HANDLE_DBC, henv, <span
            style="color: #000040;">&amp;</span>hdbc&#41;</span><span
            style="color: #008080;">;</span>
      &nbsp;
               <span style="color: #666666;">// Установка времени ожидания входа до 5 секунд</span>
               <span style="color: #0000ff;">if</span> &#40;</span>retcode <span
            style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
            style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO&#41;</span> <span
            style="color: #008000;">&#123;</span>
                  SQLSetConnectAttr&#40;</span>hdbc, SQL_LOGIN_TIMEOUT, <span
            style="color: #008000;">&#40;</span>SQLPOINTER&#41;</span><span
            style="color: #0000dd;">5</span>, <span style="color: #0000dd;">0</span>&#41;</span><span
            style="color: #008080;">;</span>
      &nbsp;
                  <span style="color: #666666;">// Подключение к источнику данных</span>
                  retcode <span style="color: #000080;">=</span> SQLConnect<span
            style="color: #008000;">&#40;</span>hdbc, &#40;</span>SQLCHAR<span
            style="color: #000040;">*</span>&#41;</span> <span style="color: #FF0000;">&quot;NorthWind&quot;</span>, SQL_NTS, <span
            style="color: #008000;">&#40;</span>SQLCHAR<span style="color: #000040;">*</span>&#41;</span> <span
            style="color: #0000ff;">NULL</span>, <span style="color: #0000dd;">0</span>, <span
            style="color: #0000ff;">NULL</span>, <span style="color: #0000dd;">0</span><span
            style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
      &nbsp;
                  <span style="color: #666666;">// Выделение идентификатора оператора</span>
                  <span style="color: #0000ff;">if</span> &#40;</span>retcode <span
            style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
            style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO&#41;</span> <span
            style="color: #008000;">&#123;</span>
                     retcode <span style="color: #000080;">=</span> SQLAllocHandle&#40;</span>SQL_HANDLE_STMT, hdbc, <span
            style="color: #000040;">&amp;</span>hstmt&#41;</span><span
            style="color: #008080;">;</span>
      &nbsp;
                     <span style="color: #666666;">// Обработка данных</span>
                     <span style="color: #0000ff;">if</span> &#40;</span>retcode <span
            style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
            style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO&#41;</span> <span
            style="color: #008000;">&#123;</span>
      &nbsp;
            <span style="color: #666666;">//После окончания работы освобождаем идентификаторы и разрываем соединение</span>
                        SQLFreeHandle&#40;</span>SQL_HANDLE_STMT, hstmt<span
            style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
                     &#125;</span>
      &nbsp;
                     SQLDisconnect&#40;</span>hdbc<span
            style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
                  &#125;</span>
      &nbsp;
                  SQLFreeHandle&#40;</span>SQL_HANDLE_DBC, hdbc&#41;</span><span
            style="color: #008080;">;</span>
               &#125;</span>
            &#125;</span>
            SQLFreeHandle&#40;</span>SQL_HANDLE_ENV, henv<span
            style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
         &#125;</span>
        &#125;</span>
      </code>
    </pre>
            <br>

            <p><strong><font size="4px">
              <ins><a href="https://msdn.microsoft.com/en-us/library/ms713946(v=vs.85).aspx">SQLDisconnect</a></ins>
            </font></strong> - закрывает соединение, связанное с конкретным идентификатором соединения.
            </p>

            <p>
              <ins><strong>Синтаксис</strong></ins>
            </p>
              <pre class='code code-sql'><label>SQL</label>
  <code>
      SQLRETURN SQLDisconnect<span >&#40;</span>
      SQLHDBC        ConnectionHandle<span>&#41;</span><span>;</span>
  </code>
            </pre>

            <div><strong>Аргументы:</strong>
              <br>
              <div class="indent-left">
                <ins>ConnectionHandle</ins>
                - (входной параметр) Идентификатор соединения.
              </div>
            </div>

            <p><strong>Возвращаемые параметры</strong></p>
            <ul><li>SQL_SUCCESS - функция выполнена успешно</li>
            <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
            <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
            <li>SQL_INVALID_HANDLE - Аргумент ConnectionHandle некоректен.</li></ul>

            <p><strong><font size="4px">
              <ins><a href="https://msdn.microsoft.com/en-us/library/ms711681(v=vs.85).aspx">SQLGetInfo</a></ins>
            </font></strong> - возвращает общую информацию о драйвере и источнике данных, связанных с подключением.
            </p>
            <p>
              <ins><strong>Синтаксис</strong></ins>
            </p>
            <pre class='code code-sql'>
    <code>
      SQLRETURN SQLGetInfo<span style="color: #008000;">&#40;</span>
        SQLHDBC         ConnectionHandle,
        SQLUSMALLINT    InfoType,
        SQLPOINTER      InfoValuePtr,
        SQLSMALLINT     BufferLength,
        SQLSMALLINT *   StringLengthPtr<span>&#41;</span><span>;</span>
    </code>
            </pre>

            <p><strong>Аргументы:</strong>
              <br>
              <ins>ConnectionHandle</ins>
              - (входной параметр) Идентификатор соединения.
              <br>
              <ins>InfoType</ins>
              - (входной параметр) Тип информации.
              <br>
              <ins>InfoValuePtr</ins>
              - (выходной параметр) Указатель на буфер, в котором возвращать информацию. В зависимости от InfoType, возвращаемая
              информация будет одного из типов: строка символов с нулевым окончанием, SQLUSMALLINT значение, SQLUINTEGER битовая
              маска, флаг SQLUINTEGER, SQLUINTEGER двоичное значение или SQLULEN значение.
              <br>
              <ins>BufferLength</ins>
              - (входной параметр) Длина буфера * InfoValuePtr.
              <br>
              <ins>StringLengthPtr</ins>
              - (выходной параметр) Указатель на буффер, в который возвращается информация, возвращаемая в * InfoValuePtr.
            </p>

            <p><strong>Возвращаемые параметры</strong></p>
            <ul><li>SQL_SUCCESS - функция выполнена успешно</li>
            <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
            <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
            <li>SQL_INVALID_HANDLE - Аргумент ConnectionHandle некоректен.</li></ul>
          </div>
        </div>
      </div>
      <!--Описание типов информации используемые в InfoType и возвращаемая информация-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#des-type-info"
        >
          Описание типов информации используемые в InfoType и возвращаемая информация
        </h3>
        <div id="des-type-info" class="accordion-body collapse">
          <div class="accordion-inner">
            <div class="indent-left">
              <ins>SQL_DATABASE_NAME</ins>
               - Строка символов с именем текущей используемой базы данных, если источник данных определяет названный объект как
              "база данных".
              В ODBC 3.x, возвращаемое значение для этого InfoType также может быть получено путем вызова SQLGetConnectAttr с
              атрибутом SQL_ATTR_CURRENT_CATALOG.
              <br><br>
              <ins>SQL_DBMS_NAME</ins>
               - Строка символов с названием СУБД.
              <br><br>
              <ins>SQL_DRIVER_NAME</ins>
               - Строка символов с именем файла драйвера, используемого для доступа к источнику данных.
              <br><br>
              <ins>SQL_MAX_CONCURRENT_ACTIVITIES</ins>
               - Значение SQLUSMALLINT, которое определяет максимальное количество активных операторов, которые драйвер может
              поддерживать для подключения.
              <br><br>
              <ins>SQL_FETCH_DIRECTION</ins>
               - Возвращает SQLINTEGER, 32-разрядную битовую маску, для определения типов выборки, связанных с курсором. Следующие
              битмаски используются, чтобы определить, какие параметры поддерживаются:
              SQL_FD_FETCH_NEXT - курсор с выборкой следующей строки;
              SQL_FD_FETCH_FIRST - курсор с выборкой первой строки;
              SQL_FD_FETCH_LAST - курсор с выборкой последней строки;
              SQL_FD_FETCH_PRIOR - курсор с выборкой предыдущей строки;
              SQL_FD_FETCH_ABSOLUTE - курсор с выборкой N-й строки;
              SQL_FD_FETCH_RELATIVE - курсор с выборкой N-й строки по отношению к текущей позиции.
              В ODBC 3.x данная функция считается устаревшей, но ODBC драйверы 3.x должны продолжать поддерживать эти типы
              информации для обеспечения обратной совместимости с приложениями ODBC 2.x.
              <br><br>
              <ins>POSITIONED_STATEMENTS</ins>
               - Возвращает SQLINTEGER, 32-разрядную битовую маску, определяя поддерживаемые операторы SQL. Следующие битмаски
              используются, чтобы определить, какие параметры поддерживаются:
              SQL_PS_POSITIONED_DELETE - поддержка позиционного оператора DELETE;
              SQL_PS_POSITIONED_UPDATE - поддержка позиционного оператора UPDATE;
              SQL_PS_SELECT_FOR_UPDATE - блокировка записи в результирующем наборе курсора.
              <br>
            </div>

            <br>
            <p>
              <strong><font size="4px">
                <ins><a href="https://msdn.microsoft.com/en-us/library/ms709291(v=vs.85).aspx">SQLGetFunctions</a></ins>
              </font></strong> - возвращает информацию о том, поддерживает ли драйвер специфическую функцию ODBC.
            </p>

            <p>
              <ins><strong>Синтаксис</strong></ins>
            </p>
            <pre class='code code-sql'><label>SQL</label>
    <code>
      SQLRETURN SQLGetFunctions&#40;
          SQLHDBC           ConnectionHandle,
          SQLUSMALLINT      FunctionId,
          SQLUSMALLINT *    SupportedPtr&#41;;
    </code>
            </pre>
            </br>

            <div><strong>Аргументы:</strong>
              <br>
              <div class="indent-left">
                <ins>ConnectionHandle</ins>
                - (входной параметр) Идентификатор соединения.
                <br>
                <ins>FunctionId</ins>
                - (входной параметр) Значение #define, которое идентифицирует функцию ODBC. Значение параметра должно быть вида:
                SQL_API_???, где ??? – имя ODBC-функции. Например, для функции SQLGetInfo значением будет SQL_API_SQLGETINFO.
                <br>
                <ins>SupportedPtr</ins>
                - (выходной параметр) Если FunctionId идентифицирует одну функцию ODBC, SupportedPtr указывает на единственное
                значение SQLUSMALLINT, который SQL_TRUE, если указанная функция поддерживается драйвером, и SQL_FALSE, если она не
                поддерживается.
              </div>
            </div>

            <p><strong>Возвращаемые параметры</strong></p>
            <ul>
              <li>SQL_SUCCESS - функция выполнена успешно</li>
              <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
              <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
              <li>SQL_INVALID_HANDLE - Аргумент ConnectionHandle некоректен.</li>
            </ul>
          </div>
        </div>
      </div>
      <!--Варианты заданий-->
      <div class="accordion-group">
        <h3
            class="accordion-header"
            data-toggle="collapse"
            data-target="#job-options-3"
        >
          Варианты заданий
        </h3>
        <div id="job-options-3" class="accordion-body collapse">
          <div class="accordion-inner">
            <p class="text-undeline">Задание типа А:</p>
            Определить, поддерживает ли драйвер заданную функцию.
            <ol class="numbered-list lab-subtitle">
              <li>SQLAllocEnv, SQLMoreResults, SQLDriverConnect, SQLRowCount;</li>
              <li>SQLFreeEnv, SQLColumnPrivileges, SQLStatistics, SQLParamData;</li>
              <li>SQLAllocConnect, SQLFetchScroll, SQLDrivers, SQLPutData;</li>
              <li>SQLFreeConnect, SQLSetStmtOption, SQLColumns, SQLTransact;</li>
              <li>SQLConnect, SQLGetCursorName, SQLTables, SQLGetTypeInfo;</li>
              <li>SQLDisconnect, SQLSetConnectOption, SQLProcedure, SQLColAttributes;</li>
              <li>SQLAllocStmt, SQLDataSources, SQLGetConnectOption, SQLCancel;</li>
              <li>SQLFreeStmt, SQLSpecialColumns, SQLParamOption, SQLGetInfo;</li>
              <li>SQLExecDirect, SQLTablePrivileges, SQLDescribeCol, SQLNativeSql;</li>
              <li>SQLExecute, SQLGetData, SQLSetCursorName, SQLGetFunctions;</li>
              <li>SQLPrepare, SQLFetch, SQLProcedureColumns, SQLPrimaryKeys;</li>
              <li>SQLBindCol, SQLForeignKeys, SQLNumResultCols, SQLSetPos.</li>
            </ol>

            <p class="text-undeline">Задание типа Б:</p>
            <p>Выбрать информацию об источнике данных. Тип выбираемых данных помечается символами S, B, N, заключенными в круглые
            скобки. Тип данных, отмеченный символом S, соответствует символьной строке, а символом N – числовому значению. Тип
            данных, отмеченный символом ?, является логическим. При этом надо определить, поддерживает ли источник данных
            указанные возможности.</p>
            <ol class="numbered-list lab-subtitle">
              <li>Имя текущей базы данных (S);</li>
              <li>Имя СУБД (S);</li>
              <li>Имя драйвера (S);</li>
              <li>Курсор с выборкой следующей строки (?);</li>
              <li>Курсор с выборкой первой строки (?);</li>
              <li>Курсор с выборкой последней строки (?);</li>
              <li>Курсор с выборкой предыдущей строки (?);</li>
              <li>Курсор с выборкой N-й строки (?);</li>
              <li>Курсор с выборкой N-й строки по отношению к текущей позиции (?);</li>
              <li>Оператор позиционного удаления (?);</li>
              <li>Оператор позиционной модификации (?);</li>
              <li>Число активных операторов в соединении (N).</li>
            </ol>
          </div>
        </div>
      </div>
    </div>

    <div id="lab-4-content" class="content-lab" >
      <h3 class="lab-title">Лабораторная работа №4</h3>
      <h3 class="lab-title">Выполнение операторов SQL в ODBC</h3>
      <p class="lab-subtitle"><b>Цель работы:</b> изучить функции ODBC для выполнения SQL-операторов, приобрести навыки использования данных функций при
        разработке клиентских приложений баз данных.</p>

      <h3 class="title-p">Методические указания</h3>
      <p>
        Данная лабораторная работа основывается на результатах предыдущей лабораторной работы.
        <br>
        Обобщенный алгоритм использования ODBC в прикладных программах представлен ниже (в скобках указаны основные
        используемые функции).
      </p>
      <p>Фаза инициализации</p>
      <ul>
        <li>Назначение идентификатора среды (SQLAllocHandle с аргументом SQL_HANDLE_ENV)</li>
        <li>Назначение идентификатора соединения (SQLAllocHandle с аргументом SQL_HANDLE_DBC)</li>
        <li>Соединение с сервером (SQLConnect)</li>
        <li>Назначение идентификатора соединения (SQLAllocHandle с аргументом SQL_HANDLE_STMT)</li>
      </ul>
      <p class="text-undeline">Фаза обработки SQL операторов</p>
      <ul>
        <li>Выполнение операторов (SQLExecDirect, SQLPrepare, SQLExecute, SQLBindParameter)</li>
      </ul>
      <p class="text-undeline">Фаза завершения</p>
      <ul>
        <li>Освобождение идентификатора оператора (SQLFreeHandle с аргуументом SQL_HANDLE_STMT)</li>
        <li>Разрыв соединения с сервером (SQLDisconnect)</li>
        <li>Освобождение идентификатора соединения (SQLFreeHandle с аргуументом SQL_HANDLE_DBC)</li>
        <li>Освобождение идентификатора окружения (SQLFreeHandle с аргуументом SQL_HANDLE_ENV)</li>
      </ul>
      <p>
        Для возможности работы с функциями ODBC в программу на языке С++ необходимо включить заголовочные файлы windows.h и
        sqlext.h
      </p>
      <pre class='code code-sql'><label>SQL</label>
  <code>
      <span style="color: #339900;">#include &lt;windows.h&gt;</span>
      <span style="color: #339900;">#include &lt;sqlext.h&gt;</span>
  </code>
      </pre>
      <h3 class="title-p">Порядок выполнения работы</h3>
      <ul>
        <li>Изучить программный интерфейс функций SQLExecDirect, SQLPrepare, SQLExecute, SQLBindParameter.</li>
        <li>Написать на языке программирования высокого уровня C/C++ программу для создания и заполнения данными таблицы в
          соответствии с заданием лабораторной работы N 2. Пользовательский интерфейс программы должен включать формы с полями
          ввода для занесения информации в таблицу. При нечетном номере варианта задания использовать прямое выполнение
          SQL-оператора, а при четном – подготавливаемое.
        </li>
        <li>Запустить ODBC-администратор и с его помощью выбрать ODBC-драйвер для используемого в программе источника
          данных.
        </li>
        <li>Выполнить программу, разработанную в п.2.</li>
        <li>Оформить отчет о проделанной работе.</li>
      </ul>

      <pre class='code code-sql'><label>SQL</label>
  <code>

  </code>
      </pre>

      <h3>Описание функций</h3>

      <p><strong><font size="4px">
        <ins><a href="https://msdn.microsoft.com/en-us/library/ms713611(v=vs.85).aspx">SQLExecDirect</a></ins>
      </font></strong> - выполняет получаемый запрос.
      </p>

      <p>
        <ins><strong>Синтаксис</strong></ins>
      </p>
      <pre class='code code-sql' style="overflow: hidden;"><label>SQL</label>
    <code>
      SQLRETURN SQLExecDirect&#40;
        SQLHSTMT     StatementHandle,
        SQLCHAR *    StatementText,
        SQLINTEGER   TextLength
      &#41;;
    </code>
      </pre>
      <div><strong>Аргументы:</strong>
        <br><br>
        <div class="indent-left">
          <ins>StatementHandle</ins>
          - (входной параметр) идентификатор оператор.
          <br>
          <ins>StatementText</ins>
          - (входной параметр) SQL запрос который будет выполнятся.
          <br>
          <ins>TextLength</ins>
          - (входной параметр) Длина * StatementText в символах.
        </div>
      </div>
      <p><strong>Возвращаемые параметры</strong></p>
      <ul>
        <li>SQL_SUCCESS - функция выполнена успешно</li>
        <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
        <li>SQL_INVALID_HANDLE - Аргумент StatementHandle некоректен.</li>
        <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
      </ul>
      <br>
      <p><strong><font size="4px">
        <ins><a href="https://msdn.microsoft.com/ru-ru/library/ms131661(v=sql.100).aspx">SQLPrepare</a></ins>
      </font></strong> - готовит строку SQL для выполнения.
      </p>

      <p>
        <ins><strong>Синтаксис</strong></ins>
      </p>
      <pre class='code code-sql'><label>SQL</label>
  <code>
      SQLRETURN SQLPrepare&#40;
      SQLHSTMT     StatementHandle,
      SQLCHAR *    StatementText,
      SQLINTEGER   TextLength&#41;;
  </code>
      </pre>


      <div><strong>Аргументы:</strong>
        <br><br>
        <div class="indent-left">
          <ins>StatementHandle</ins>
          - (входной параметр) идентификатор оператор.
          <br>
          <ins>StatementText</ins>
          - (входной параметр) SQL запрос который будет выполнятся.
          <br>
          <ins>TextLength</ins>
          - (входной параметр) Длина * StatementText в символах.
        </div>
      </div>

      <p><strong>Возвращаемые параметры</strong></p>
      <ul>
        <li>SQL_SUCCESS - функция выполнена успешно</li>
        <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
        <li>SQL_INVALID_HANDLE - Аргумент StatementHandle некоректен.</li>
        <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
      </ul>
      <br>
      <p><strong><font size="4px">
        <ins><a href="https://msdn.microsoft.com/en-us/library/ms713584(v=vs.85).aspx">SQLExecute</a></ins>
      </font></strong> - выполняет подготовленное заявление, используя текущие значения переменных параметров, если
        какие-либо параметровы существуют в инструкции.
      </p>

      <p>
        <ins><strong>Синтаксис</strong></ins>
      </p>
      <pre class='code code-sql'><label>SQL</label>
  <code>
      SQLRETURN SQLPrepare&#40;
      SQLHSTMT     StatementHandle&#41;;
  </code>
      </pre>

      <div><strong>Аргументы:</strong>
        <br><br>
        <div class="indent-left">
          <ins>StatementHandle</ins>
          - (входной параметр) идентификатор оператора.
        </div>
      </div>

      <p><strong>Возвращаемые параметры</strong></p>
      <ul>
        <li>SQL_SUCCESS - функция выполнена успешно</li>
        <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
        <li>SQL_INVALID_HANDLE - Аргумент StatementHandle некоректен.</li>
        <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
      </ul>

      <p><strong><font size="4px">
        <ins><a href="https://msdn.microsoft.com/ru-ru/library/ms131462(v=sql.120).aspx">SQLBindParameter</a></ins>
      </font></strong> - связывает буфер с параметром в операторе SQL. SQLBindParameter поддерживает привязку к типу данных
        Unicode C, даже если основной драйвер не поддерживает Unicode данные.
      </p>

      <p>
        <ins><strong>Синтаксис</strong></ins>
      </p>
      <pre class='code code-sql'><label>SQL</label>
  <code>
      SQLRETURN SQLBindParameter&#40;
      SQLHSTMT        StatementHandle,
      SQLUSMALLINT    ParameterNumber,
      SQLSMALLINT     InputOutputType,
      SQLSMALLINT     ValueType,
      SQLSMALLINT     ParameterType,
      SQLULEN         ColumnSize,
      SQLSMALLINT     DecimalDigits,
      SQLPOINTER      ParameterValuePtr,
      SQLLEN          BufferLength,
      SQLLEN *        StrLen_or_IndPtr&#41;;
  </code>
      </pre>


      <div><strong>Аргументы:</strong>
        <br><br>
        <div class="indent-left">
          <ins>StatementHandle</ins>
          - (входной параметр) идентификатор оператора.
          <br><br>
          <ins>ParameterNumber</ins>
          - (входной параметр) номер параметра, упорядоченные последовательно в порядке возрастания параметра, начиная с 1.
          <br><br>
          <ins>InputOutputType</ins>
          - (входной параметр) Тип параметра, может принимать одно из трех значений: SQL_PARAM_INPUT, SQL_PARAM_INPUT_OUTPUT
          или SQL_PARAM_OUTPUT. Значение SQL_PARAM_INPUT используется для всех параметров, которые не включены в процедуру, а
          также для процедур, использующих параметры ввода. Значение SQL_PARAM_INPUT_OUTPUT маркирует параметр ввода/вывода в
          процедуре. Значение SQL_PARAM_OUTPUT маркирует значение возврата или параметр вывода в процедуре.
          <br><br>
          <ins>ValueType</ins>
          - (входной параметр) Тип данных C параметра. Это тип данных, из которого конвертируются данные. C-тип данных
          параметра может быть одним из следующих значений: SQL_C_BINARY, SQL_C_BIT, SQL_C_CHAR, SQL_C_DATE, SQL_C_DEFAULT,
          SQL_C_DOUBLE, SQL_C_FLOAT, SQL_C_SLONG, SQL_C_SSHORT, SQL_STINYINT, SQL_C_TIME, SQL_C_TIMESTAMP, SQL_C_ULONG,
          SQL_C_USHORT, SQL_C_UTINYINT, SQL_C_DEFAULT.
          <br><br>
          <ins>ParameterType</ins>
          - (входной параметр) Тип данных SQL параметра. Это тип данных, в который конвертируются данные. Он должен совпадать
          с SQL-типом соответствующего столбца. SQL-тип данных может быть одним из следующих значений: SQL_BIGINT, SQL_BINARY,
          SQL_BIT, SQL_CHAR, SQL_DATE, SQL_DECIMAL, SQL_DOUBLE, SQL_FLOAT, SQL_INTEGER, SQL_LONGVARBINARY, SQL_LONGVARCHAR,
          SQL_NUMERIC, SQL_REAL, SQL_SMALLINT, SQL_TIME, SQL_TIMESTAMP, SQL_TINYINT, SQL_VARBINARY, SQL_VARCHAR.
          <br><br>
          <ins>ColumnSize</ins>
          - (входной параметр) Точность столбца источника данных.
          <br><br>
          <ins>DecimalDigits</ins>
          - (входной параметр) Размер столбца источника данных.
          <br><br>
          <ins>ParameterValuePtr</ins>
          - Указатель на буфер для данных параметра.
          <br><br>
          <ins>BufferLength</ins>
          - Длина буфера ParameterValuePtr в байтах.
          <br><br>
          <ins>StrLen_or_IndPtr</ins>
          - Указатель на буфер длины параметра.
        </div>
      </div>

      <p><strong>Возвращаемые параметры</strong></p>
      <ul>
        <li>SQL_SUCCESS - функция выполнена успешно</li>
        <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
        <li>SQL_INVALID_HANDLE - Аргумент StatementHandle некоректен.</li>
        <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
      </ul>

      <p>В данном примере добавим запись в таблицу с 2 столбцами. Типа VARCHAR и INTEGER.</p>
      <pre class='code code-sql'><label>C++</label>
  <code>
      <span style="color: #339900;">#define EMPLOYEE_ID_LEN 20</span>
     <span style="color: #666666;">//...</span>
     <span style="color: #0000ff;">char</span><span style="color: #000040;">*</span> queryPartOne <span
      style="color: #000080;">=</span> <span style="color: #FF0000;">&quot;INSERT INTO table (word, number) VALUES (?, ?)&quot;</span><span
      style="color: #008080;">;</span>
     SQLCHAR word<span style="color: #008000;">&#91;</span>EMPLOYEE_ID_LEN<span style="color: #008000;">&#93;</span><span
      style="color: #008080;">;</span>
     SQLSMALLINT number<span style="color: #008080;">;</span>
     <span style="color: #666666;">//производим соединение с БД и прочие действия</span>
     <span style="color: #666666;">//...</span>
     SQLINTEGER cbCustID <span style="color: #000080;">=</span> <span style="color: #0000dd;">0</span>, cbEmployeeID <span
      style="color: #000080;">=</span> SQL_NTS<span style="color: #008080;">;</span> <span style="color: #666666;">//переменные для задания точности</span>
    &nbsp;
     <span style="color: #666666;">//определяем параметры используемые в SQL инструкции</span>
     retcode <span style="color: #000080;">=</span> SQLBindParameter<span style="color: #008000;">&#40;</span>hstmt, <span
      style="color: #0000dd;">1</span>, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, EMPLOYEE_ID_LEN, <span
      style="color: #0000dd;">0</span>, word, <span style="color: #0000dd;">0</span>, <span style="color: #000040;">&amp;</span>cbEmployeeID<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
     retcode <span style="color: #000080;">=</span> SQLBindParameter<span style="color: #008000;">&#40;</span>hstmt, <span
      style="color: #0000dd;">2</span>, SQL_PARAM_INPUT, SQL_C_SSHORT, SQL_INTEGER, <span
      style="color: #0000dd;">0</span>, <span style="color: #0000dd;">0</span>, <span
      style="color: #000040;">&amp;</span>number, <span style="color: #0000dd;">0</span>, <span
      style="color: #000040;">&amp;</span>cbCustID<span style="color: #008000;">&#41;</span><span
      style="color: #008080;">;</span>
     <span style="color: #666666;">//готовим SQL инструкцию к выполнению</span>
     retcode <span style="color: #000080;">=</span> SQLPrepare<span style="color: #008000;">&#40;</span>hstmt, <span
      style="color: #008000;">&#40;</span>SQLCHAR<span style="color: #000040;">*</span><span
      style="color: #008000;">&#41;</span>query, SQL_NTS<span style="color: #008000;">&#41;</span><span
      style="color: #008080;">;</span>
     <span style="color: #666666;">//задаём значения переменным используемые в качестве параметра</span>
     strcpy_s<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#40;</span><span
      style="color: #0000ff;">char</span><span style="color: #000040;">*</span><span
      style="color: #008000;">&#41;</span>word, _countof<span style="color: #008000;">&#40;</span>word<span
      style="color: #008000;">&#41;</span>, <span style="color: #FF0000;">&quot;value&quot;</span><span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
     ram <span style="color: #000080;">=</span> <span style="color: #0000dd;">10</span><span
      style="color: #008080;">;</span>
     <span style="color: #666666;">//выполняем SQL инструкцию</span>
     retcode <span style="color: #000080;">=</span> SQLExecute<span style="color: #008000;">&#40;</span>hstmt<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
  </code>
      </pre>
    </div>

    <div id="lab-5-content" class="content-lab">
      <h3 class="lab-title">Лабораторная работа №5</h3>
      <h3 class="lab-title">Выборка данных из результирующего множества в ODBC</h3>
      <p class="lab-subtitle"><b>Цель работы:</b> изучить функции ODBC для выборки данных из результирующей таблицы, изучить скроллируемые курсоры в
        ODBC, приобрести навыки использования данных функций при разработке клиентских приложений баз данных.</p>

      <h3 class="title-p">Методические указания</h3>
      <p>Создание курсора в ODBC не предполагает использование SQL-оператора объявления курсора. Курсор создается
        автоматически при выполнении оператора выборки SELECT. При этом идентификатор данного оператора SELECT должен
        использоваться для выборки данных из результирующей таблицы.
        <br>
        При выполнении данной лабораторной работы в полном объеме используется алгоритм использования ODBC, приведенный в
        описании лабораторной работы N 3
        <br>
        Для выборки всех данных из заданных столбцов результирующей таблицы с помощью функций SQLBindCol и SQLFetch следует
        использовать следующий алгоритм:
      </p>
      <ol class="numbered-list lab-subtitle">
        <li>Вызвать функцию SQLBindCol один раз для каждого столбца, который должен быть возвращен из результирующей таблицы.</li>
        <li>Вызвать функцию SQLFetch для перемещения курсора на следующую строку и возврата данных из связанных столбцов.</li>
        <li>Повторить шаг 2 до тех пор, пока функция SQLFetch не возвратит SQL_NO_DATA_FOUND.</li>
      </ol>
      <p>Для выборки всех данных из заданных столбцов результирующей таблицы с помощью функций SQLGetData и SQLFetch следует
      использовать следующий алгоритм:</p>
      <ol class="numbered-list lab-subtitle">
        <li>Вызывать функцию SQLFetch для перемещения курсора на следующую строку.</li>
        <li>Вызвать функцию SQLGetData для каждого из заданных столбцов.</li>
        <li>Повторить шаги 1 и 2 до тех пор, пока функция SQLFetch не возвратит SQL_NO_DATA_FOUND.</li>
      </ol>

      <h3 class="title-p">Порядок выполнения работы и варианты заданий</h3>
      <ol class="numbered-list lab-subtitle">
        <li>Изучить программный интерфейс функций SQLFetch, SQLBindCol, SQLGetData, SQLFetchScroll, SQLSetStmtOption.</li>
        <li>Написать на языке программирования высокого уровня С/C++:</li>
        <ul>
          <li>программу для создания курсора в ODBC. Определение курсора берется из вариантов заданий к лабораторной работе
            N 2. При нечетном номере варианта задания следует использовать статические курсоры, а при четном – динамические.
          </li>
          <li>программу для просмотра результирующей таблицы с использованием функций SQLFetch и SQLBindCol (для нечетного
            номера варианта задания) и функции SQLGetData (для четного номера варианта задания);
          </li>
          <li>программу для различных типов выборки строк из результирующей таблицы с использованием функции SQLFetchScroll.
            Пользовательский интерфейс программы должен включать элементы управления (например, кнопки, диалоговые окна и
            т.д.) для показа первой, последней, следующей и предыдущей строк, а также строк с абсолютным и относительным
            номером N.
          </li>
        </ul>
        <li>Запустить ODBC-администратор и с его помощью выбрать ODBC-драйвер для используемого в программе источника
          данных.
        </li>
        <li>Выполнить программу, разработанную в п.2.</li>
        <li>Оформить отчет о проделанной работе.</li>
      </ol>

      <h3 class="title-p">Описание функций</h3>

      <p><strong><font size="4px">
        <ins><a href="https://msdn.microsoft.com/en-us/library/ms711010(v=vs.85).aspx">SQLBindCol</a></ins>
      </font></strong> - связывает буферы данных приложения со столбцами в наборе результатов.
      </p>

      <p>
        <ins><strong>Синтаксис</strong></ins>
      </p>
      <pre class='code code-sql' style="overflow: hidden;"><label>SQL</label>
  <code>
      SQLRETURN SQLBindCol&#40;
        SQLHSTMT       StatementHandle,
        SQLUSMALLINT   ColumnNumber,
        SQLSMALLINT    TargetType,
        SQLPOINTER     TargetValuePtr,
        SQLLEN         BufferLength,
        SQLLEN *       StrLen_or_Ind
      &#41;;
  </code>
      </pre>

      <div><strong>Аргументы:</strong>
        <br><br>
        <div class="indent-left">
          <ins>StatementHandle</ins>
          - (входной параметр) идентификатор оператора.
          <br><br>
          <ins>ColumnNumber</ins>
          - (входной параметр) Номер столбца результирующего набора данных для привязки. Нумерация начинается с 1.
          <br><br>
          <ins>TargetType</ins>
          - (входной параметр) Тип данных C параметра. Это тип данных, из которого конвертируются данные. C-тип данных
          параметра может быть одним из следующих значений: SQL_C_BINARY, SQL_C_BIT, SQL_C_CHAR, SQL_C_DATE, SQL_C_DEFAULT,
          SQL_C_DOUBLE, SQL_C_FLOAT, SQL_C_SLONG, SQL_C_SSHORT, SQL_STINYINT, SQL_C_TIME, SQL_C_TIMESTAMP, SQL_C_ULONG,
          SQL_C_USHORT, SQL_C_UTINYINT, SQL_C_DEFAULT.
          <br><br>
          <ins>TargetValuePtr</ins>
          - Указатель на буфер данных для привязки к столбцу.
          <br><br>
          <ins>BufferLength</ins>
          - (входной параметр) Длина буфера * TargetValuePtr в байтах.
          <br><br>
          <ins>StrLen_or_IndPtr</ins>
          - Указатель на буфер длины для привязки к столбцу.
        </div>
      </div>

      <p><strong>Возвращаемые параметры</strong></p>
      <ul>
        <li>SQL_SUCCESS - функция выполнена успешно</li>
        <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
        <li>SQL_INVALID_HANDLE - Аргумент StatementHandle некоректен.</li>
        <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
      </ul>
      <br>
      <p><strong><font size="4px">
        <ins><a href="https://msdn.microsoft.com/en-us/library/ms712424(v=vs.85).aspx">SQLFetch</a></ins>
      </font></strong> - выбирает следующия набор записей данных из таблицы и возвращает данные для всех связанных столбцов.
      </p>

      <p>
        <ins><strong>Синтаксис</strong></ins>
      </p>

      <pre class='code code-sql'><label>SQL</label>
  <code>
      SQLRETURN SQLBindCol&#40;
      SQLHSTMT       StatementHandle&#41;;
  </code>
      </pre>
      <div><strong>Аргументы:</strong>
        <br><br>
        <div class="indent-left">
          <ins>StatementHandle</ins>
          - (входной параметр) идентификатор оператора.
        </div>
      </div>

      <p><strong>Возвращаемые параметры</strong></p>
      <ul>
        <li>SQL_SUCCESS - функция выполнена успешно</li>
        <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
        <li>SQL_INVALID_HANDLE - Аргумент StatementHandle некоректен.</li>
        <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
      </ul>

      <br>
      <p>Пример выборки данных:</p>
      <p>В следующем примере, приложение выполняет оператор SELECT, для таблицы клиентов, возвращает результирующий набор
        идентификаторов клиентов, имен и телефонных номеров, отсортированных по именам. Затем он вызывает SQLBindCol
        связывая столбцы данных для локальных буферов. Наконец, приложение извлекает каждую строку данных при помощи
        SQLFetch и печатает имя, идентификатор и номер телефона каждого клиента.
        <br>
        Данный пример взят с сайта https://msdn.microsoft.com.
      </p>

      <pre class='code code-sql'><label>C++</label>
  <code>
      <span style="color: #339900;">#include &lt;windows.h&gt;</span>
    <span style="color: #339900;">#include &lt;stdio.h&gt;</span>
    &nbsp;
    <span style="color: #339900;">#define UNICODE</span>
    <span style="color: #339900;">#include &lt;sqlext.h&gt;</span>
    &nbsp;
    <span style="color: #339900;">#define NAME_LEN 50</span>
    <span style="color: #339900;">#define PHONE_LEN 20</span>
    &nbsp;
    <span style="color: #0000ff;">void</span> show_error<span style="color: #008000;">&#40;</span><span
      style="color: #008000;">&#41;</span> <span style="color: #008000;">&#123;</span>
       <span style="color: #0000dd;">printf</span><span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;error<span
      style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    <span style="color: #008000;">&#125;</span>
    &nbsp;
    <span style="color: #0000ff;">int</span> main<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span
      style="color: #008000;">&#123;</span>
       SQLHENV henv<span style="color: #008080;">;</span>
       SQLHDBC hdbc<span style="color: #008080;">;</span>
       SQLHSTMT hstmt <span style="color: #000080;">=</span> <span style="color: #0000dd;">0</span><span
      style="color: #008080;">;</span>
       SQLRETURN retcode<span style="color: #008080;">;</span>
       SQLWCHAR szName<span style="color: #008000;">&#91;</span>NAME_LEN<span
      style="color: #008000;">&#93;</span>, szPhone<span style="color: #008000;">&#91;</span>PHONE_LEN<span
      style="color: #008000;">&#93;</span>, sCustID<span style="color: #008000;">&#91;</span>NAME_LEN<span
      style="color: #008000;">&#93;</span><span style="color: #008080;">;</span>
       SQLLEN cbName <span style="color: #000080;">=</span> <span style="color: #0000dd;">0</span>, cbCustID <span
      style="color: #000080;">=</span> <span style="color: #0000dd;">0</span>, cbPhone <span
      style="color: #000080;">=</span> <span style="color: #0000dd;">0</span><span style="color: #008080;">;</span>
    &nbsp;
       <span style="color: #666666;">// Выделение идентификатора среды</span>
       retcode <span style="color: #000080;">=</span> SQLAllocHandle<span style="color: #008000;">&#40;</span>SQL_HANDLE_ENV, SQL_NULL_HANDLE, <span
      style="color: #000040;">&amp;</span>henv<span style="color: #008000;">&#41;</span><span
      style="color: #008080;">;</span>
    &nbsp;
       <span style="color: #666666;">// Установите атрибут версии ODBC</span>
       <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO<span style="color: #008000;">&#41;</span> <span
      style="color: #008000;">&#123;</span>
          retcode <span style="color: #000080;">=</span> SQLSetEnvAttr<span style="color: #008000;">&#40;</span>henv, SQL_ATTR_ODBC_VERSION, <span
      style="color: #008000;">&#40;</span>SQLPOINTER<span style="color: #000040;">*</span><span
      style="color: #008000;">&#41;</span>SQL_OV_ODBC3, <span style="color: #0000dd;">0</span><span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    &nbsp;
          <span style="color: #666666;">// Выделение идентификатора соединения</span>
          <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO<span style="color: #008000;">&#41;</span> <span
      style="color: #008000;">&#123;</span>
             retcode <span style="color: #000080;">=</span> SQLAllocHandle<span style="color: #008000;">&#40;</span>SQL_HANDLE_DBC, henv, <span
      style="color: #000040;">&amp;</span>hdbc<span style="color: #008000;">&#41;</span><span
      style="color: #008080;">;</span>
    &nbsp;
             <span style="color: #666666;">// Установка времени ожидания входа до 5 секунд</span>
             <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO<span style="color: #008000;">&#41;</span> <span
      style="color: #008000;">&#123;</span>
                SQLSetConnectAttr<span style="color: #008000;">&#40;</span>hdbc, SQL_LOGIN_TIMEOUT, <span
      style="color: #008000;">&#40;</span>SQLPOINTER<span style="color: #008000;">&#41;</span><span
      style="color: #0000dd;">5</span>, <span style="color: #0000dd;">0</span><span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    &nbsp;
                <span style="color: #666666;">// Подключение к источнику данных</span>
                retcode <span style="color: #000080;">=</span> SQLConnect<span
      style="color: #008000;">&#40;</span>hdbc, <span style="color: #008000;">&#40;</span>SQLWCHAR<span
      style="color: #000040;">*</span><span style="color: #008000;">&#41;</span> L<span style="color: #FF0000;">&quot;NorthWind&quot;</span>, SQL_NTS, <span
      style="color: #008000;">&#40;</span>SQLWCHAR<span style="color: #000040;">*</span><span
      style="color: #008000;">&#41;</span> <span style="color: #0000ff;">NULL</span>, <span style="color: #0000dd;">0</span>, <span
      style="color: #0000ff;">NULL</span>, <span style="color: #0000dd;">0</span><span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    &nbsp;
                <span style="color: #666666;">// Выделение идентификатора оператора</span>
                <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO<span style="color: #008000;">&#41;</span> <span
      style="color: #008000;">&#123;</span>
                   retcode <span style="color: #000080;">=</span> SQLAllocHandle<span style="color: #008000;">&#40;</span>SQL_HANDLE_STMT, hdbc, <span
      style="color: #000040;">&amp;</span>hstmt<span style="color: #008000;">&#41;</span><span
      style="color: #008080;">;</span>
    &nbsp;
                   retcode <span style="color: #000080;">=</span> SQLExecDirect<span style="color: #008000;">&#40;</span>hstmt, <span
      style="color: #008000;">&#40;</span>SQLWCHAR <span style="color: #000040;">*</span><span
      style="color: #008000;">&#41;</span> L<span style="color: #FF0000;">&quot;SELECT CustomerID, ContactName, Phone FROM CUSTOMERS ORDER BY 2, 1, 3&quot;</span>, SQL_NTS<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
                   <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO<span style="color: #008000;">&#41;</span> <span
      style="color: #008000;">&#123;</span>
    &nbsp;
                      <span style="color: #666666;">// Привязка столбцов с номером 1, 2, и 3</span>
                      retcode <span style="color: #000080;">=</span> SQLBindCol<span style="color: #008000;">&#40;</span>hstmt, <span
      style="color: #0000dd;">1</span>, SQL_C_CHAR, <span style="color: #000040;">&amp;</span>sCustID, <span
      style="color: #0000dd;">100</span>, <span style="color: #000040;">&amp;</span>cbCustID<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
                      retcode <span style="color: #000080;">=</span> SQLBindCol<span style="color: #008000;">&#40;</span>hstmt, <span
      style="color: #0000dd;">2</span>, SQL_C_CHAR, szName, NAME_LEN, <span style="color: #000040;">&amp;</span>cbName<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
                      retcode <span style="color: #000080;">=</span> SQLBindCol<span style="color: #008000;">&#40;</span>hstmt, <span
      style="color: #0000dd;">3</span>, SQL_C_CHAR, szPhone, PHONE_LEN, <span style="color: #000040;">&amp;</span>cbPhone<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    &nbsp;
                      <span style="color: #666666;">// Выборка и печатать каждой строки данных. В случаее ошибки, отобразить сообщение и выйти.</span>
                      <span style="color: #0000ff;">for</span> <span style="color: #008000;">&#40;</span>i <span
      style="color: #008080;">;</span> <span style="color: #008080;">;</span> i<span
      style="color: #000040;">++</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#123;</span>
                         retcode <span style="color: #000080;">=</span> SQLFetch<span style="color: #008000;">&#40;</span>hstmt<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
                         <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>retcode <span
      style="color: #000080;">==</span> SQL_ERROR <span style="color: #000040;">||</span> retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO<span style="color: #008000;">&#41;</span>
                            show_error<span style="color: #008000;">&#40;</span><span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
                         <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO<span style="color: #008000;">&#41;</span>
                            wprintf<span style="color: #008000;">&#40;</span>L<span style="color: #FF0000;">&quot;%d: %S %S %S<span
      style="color: #000099; font-weight: bold;">\n</span>&quot;</span>, i <span
      style="color: #000040;">+</span> <span style="color: #0000dd;">1</span>, sCustID, szName, szPhone<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
                         <span style="color: #0000ff;">else</span>
                            <span style="color: #0000ff;">break</span><span style="color: #008080;">;</span>
                      <span style="color: #008000;">&#125;</span>
                   <span style="color: #008000;">&#125;</span>
    &nbsp;
                   <span style="color: #666666;">// Обработка данных</span>
                   <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO<span style="color: #008000;">&#41;</span> <span
      style="color: #008000;">&#123;</span>
                      <span style="color: #666666;">//Тут работаем с данными</span>
                      SQLCancel<span style="color: #008000;">&#40;</span>hstmt<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span><span style="color: #666666;">//отменяет обработку оператора</span>
                      SQLFreeHandle<span style="color: #008000;">&#40;</span>SQL_HANDLE_STMT, hstmt<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
                   <span style="color: #008000;">&#125;</span>
    &nbsp;
                   SQLDisconnect<span style="color: #008000;">&#40;</span>hdbc<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
                <span style="color: #008000;">&#125;</span>
    &nbsp;
                SQLFreeHandle<span style="color: #008000;">&#40;</span>SQL_HANDLE_DBC, hdbc<span style="color: #008000;">&#41;</span><span
      style="color: #008080;">;</span>
             <span style="color: #008000;">&#125;</span>
          <span style="color: #008000;">&#125;</span>
          SQLFreeHandle<span style="color: #008000;">&#40;</span>SQL_HANDLE_ENV, henv<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
       <span style="color: #008000;">&#125;</span>
    <span style="color: #008000;">&#125;</span>
  </code>
      </pre>

      <br>
      <br>
      <p><strong><font size="4px">
        <ins><a href="https://msdn.microsoft.com/en-us/library/ms715441(v=vs.85).aspx">SQLGetData</a></ins>
      </font></strong> - извлекает данные из одного столбца таблицы. Эта функция позволяет выполнить выборку данных из
        столбцов, которые не были связаны с помощью функции SQLBindCol.
        <br>
        Данная функция имеет те же параметры, что и функция SQLBiindCol. Функция SQLGetData полезна в тех случаях, когда нет
        нужды выполнять выборку одних и тех же столбцов для каждой строки результирующей таблицы при вызове SQLFetch.
      </p>


      <p>Пример выборки данных:</p>

        <p>
          В следующем примере, приложение выполняет оператор SELECT, чтобы вернуть результирующий набор идентификаторов
          клиентов, имен и телефонных номеров, отсортированных по имени, ID и номеру телефона. Для каждой строки данных,
          вызывается SQLFetch размещая курсор на следующую строку. SQLGetData вызывается для извлечения выбираемых данных;
          буферы для данных и возвращаемого числа байтов указаны в вызове SQLGetData. И, наконец, печатается имя,
          идентификатор и номер телефона каждого сотрудника.
          <br>
          Данный пример взят с сайта https://msdn.microsoft.com.
        </p>

      <pre class='code code-sql'><label>C++</label>
  <code>
      <span style="color: #339900;">#define NAME_LEN 50</span>
    <span style="color: #339900;">#define PHONE_LEN 50</span>
    &nbsp;
    SQLCHAR      szName<span style="color: #008000;">&#91;</span>NAME_LEN<span style="color: #008000;">&#93;</span>, szPhone<span
      style="color: #008000;">&#91;</span>PHONE_LEN<span style="color: #008000;">&#93;</span><span
      style="color: #008080;">;</span>
    SQLINTEGER   sCustID, cbName, cbAge, cbBirthday<span style="color: #008080;">;</span>
    SQLRETURN    retcode<span style="color: #008080;">;</span>
    SQLHSTMT     hstmt<span style="color: #008080;">;</span>
    &nbsp;
    retcode <span style="color: #000080;">=</span> SQLExecDirect<span style="color: #008000;">&#40;</span>hstmt,
       <span style="color: #FF0000;">&quot;SELECT CUSTID, NAME, PHONE FROM CUSTOMERS ORDER BY 2, 1, 3&quot;</span>,
       SQL_NTS<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    &nbsp;
    <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>retcode <span style="color: #000080;">==</span> SQL_SUCCESS<span
      style="color: #008000;">&#41;</span> <span style="color: #008000;">&#123;</span>
       <span style="color: #0000ff;">while</span> <span style="color: #008000;">&#40;</span>TRUE<span
      style="color: #008000;">&#41;</span> <span style="color: #008000;">&#123;</span>
          retcode <span style="color: #000080;">=</span> SQLFetch<span style="color: #008000;">&#40;</span>hstmt<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
          <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>retcode <span
      style="color: #000080;">==</span> SQL_ERROR <span style="color: #000040;">||</span> retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO<span style="color: #008000;">&#41;</span> <span
      style="color: #008000;">&#123;</span>
             show_error<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span
      style="color: #008080;">;</span>
          <span style="color: #008000;">&#125;</span>
          <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS <span style="color: #000040;">||</span> retcode <span
      style="color: #000080;">==</span> SQL_SUCCESS_WITH_INFO<span style="color: #008000;">&#41;</span><span
      style="color: #008000;">&#123;</span>
    &nbsp;
             <span style="color: #ff0000; font-style: italic;">/* Получить данные для столбцов 1, 2, и 3 */</span>
    &nbsp;
             SQLGetData<span style="color: #008000;">&#40;</span>hstmt, <span style="color: #0000dd;">1</span>, SQL_C_ULONG, <span
      style="color: #000040;">&amp;</span>sCustID, <span style="color: #0000dd;">0</span>, <span
      style="color: #000040;">&amp;</span>cbCustID<span style="color: #008000;">&#41;</span><span
      style="color: #008080;">;</span>
             SQLGetData<span style="color: #008000;">&#40;</span>hstmt, <span style="color: #0000dd;">2</span>, SQL_C_CHAR, szName, NAME_LEN, <span
      style="color: #000040;">&amp;</span>cbName<span style="color: #008000;">&#41;</span><span
      style="color: #008080;">;</span>
             SQLGetData<span style="color: #008000;">&#40;</span>hstmt, <span style="color: #0000dd;">3</span>, SQL_C_CHAR, szPhone, PHONE_LEN,
                <span style="color: #000040;">&amp;</span>cbPhone<span style="color: #008000;">&#41;</span><span
      style="color: #008080;">;</span>
    &nbsp;
             <span style="color: #ff0000; font-style: italic;">/* Вывести строку данных */</span>
    &nbsp;
             <span style="color: #0000dd;">fprintf</span><span style="color: #008000;">&#40;</span>out, <span
      style="color: #FF0000;">&quot;%-5d %-*s %*s&quot;</span>, sCustID, NAME_LEN<span
      style="color: #000040;">-</span><span style="color: #0000dd;">1</span>, szName,
                PHONE_LEN<span style="color: #000040;">-</span><span style="color: #0000dd;">1</span>, szPhone<span
      style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
          <span style="color: #008000;">&#125;</span> <span style="color: #0000ff;">else</span> <span
      style="color: #008000;">&#123;</span>
             <span style="color: #0000ff;">break</span><span style="color: #008080;">;</span>
          <span style="color: #008000;">&#125;</span>
       <span style="color: #008000;">&#125;</span>
    <span style="color: #008000;">&#125;</span>
  </code>
      </pre>

      <p><strong><font size="4px">
        <ins>
          <a href="https://msdn.microsoft.com/en-us/library/ms714682(v=vs.85).aspx">SQLFetchScroll</a>
        </ins>
      </font></strong> - извлекает указанный набор строк данных из таблицы и возвращает данные для всех связанных столбцов.
        Наборы строк могут быть указаны при абсолютном или относительном положении или с помощью закладки.
      </p>

      <p>
        <ins><strong>Синтаксис</strong></ins>
      </p>

      <pre class='code code-sql'><label>SQL</label>
  <code>
      SQLRETURN SQLFetchScroll&#40;
      SQLHSTMT       StatementHandle,
      SQLSMALLINT   FetchOrientation,
      SQLLEN        FetchOffset&#41;;
  </code>
      </pre>

      <div><strong>Аргументы:</strong>
        <br><br>
        <div class="indent-left">
          <ins>StatementHandle</ins>
          - (входной параметр) идентификатор оператора.
          <br>
          <ins>FetchOrientation</ins>
          - (входной параметр) Тип выборки:
          <ul>
            <li>SQL_FETCH_NEXT - Возвращает следующий набор строк. Это эквивалентно вызову SQLFetch.
              SQLFetchScroll игнорирует значение FetchOffset.
            </li>
            <li>SQL_FETCH_PRIOR - Возвращение предшествующего набора строк.
              SQLFetchScroll игнорирует значение FetchOffset.
            </li>
            <li>SQL_FETCH_FIRST - Возвращает первый набор строк в наборе результатов.
              SQLFetchScroll игнорирует значение FetchOffset.
            </li>
            <li>SQL_FETCH_LAST - Возвращает последний полный набор строк в наборе результатов.
              SQLFetchScroll игнорирует значение FetchOffset.
            </li>
            <li>SQL_FETCH_ABSOLUTE - Возвращает набор строк, начиная со строки FetchOffset.</li>
            <li>SQL_FETCH_RELATIVE - Возвращение набора строк FetchOffset с начала текущего набора строк.</li>
            <li>SQL_FETCH_BOOKMARK - Возвращение набора строк FetchOffset закладки заданной атрибутом SQL_ATTR_FETCH_BOOKMARK_PTR
              оператора.
            </li>
          </ul>
          <ins>FetchOffset</ins>
          - (входной параметр) Номер строки для выборки. Интерпретация этого аргумента зависит от значения аргумента
          FetchOrientation.
        </div>
      </div>

      <p><strong>Возвращаемые параметры</strong></p>
      <ul>
        <li>SQL_SUCCESS - функция выполнена успешно</li>
        <li>SQL_SUCCESS_WITH_INFO - функция выполнена успешно, но имеется дополнительная информация.</li>
        <li>SQL_INVALID_HANDLE - Аргумент StatementHandle некоректен.</li>
        <li>SQL_ERROR - произошла ошибка, более подробную информацию можно получить при вызове функции SQLGetDiagRec.</li>
      </ul>
    </div>
  </div>
</div>
</body>
</html>